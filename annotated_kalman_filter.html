<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Annotated Kalman Filter</title>

    <!-- put window.MathJax script before importing the rest of MathJax 
     https://docs.mathjax.org/en/latest/web/configuration.html describes async vs defer for loading
     https://docs.mathjax.org/en/latest/web/configuration.html#performing-actions-after-typesetting 
     describes how to perform actions after typesetting-->
    <script>
        function create_tooltips(formula_elements) {
            // must be called AFTER MathJax typesets everything and generates the divs
            for (const object of formula_elements) {
                object.create_tooltip();
            }
        }

        function create_highlights(formula_elements) {
            // must be called AFTER MathJax typesets everything and generates the divs
            for (const object of formula_elements) {
                object.create_highlight();
            }
        }

        window.MathJax = {
            //Enable macros \class, \cssId, \href, \style
            loader: {load: ['[tex]/html']}, 
            tex: {packages: {'[+]': ['html']}},
            // Once MathJax has finished typesetting, create tooltips for the new divs
            startup: {
                ready: () => {
                    MathJax.startup.defaultReady();
                    MathJax.startup.promise.then(() => {
                        create_tooltips([...Object.values(formulas), ...Object.values(variables)]);
                        create_highlights([...Object.values(formulas), ...Object.values(variables)]);
                    });
                }
            }
        };
    </script>
    <script id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>

    <!-- Tippy.js for hover tooltips -->
    <script src="https://unpkg.com/@popperjs/core@2"></script>
    <script src="https://unpkg.com/tippy.js@6"></script>
    <link rel="stylesheet" href="https://unpkg.com/tippy.js@6/animations/scale.css">
    
</head>
<body>
    <select id="naming-convention">
        <option value="alt0">Alt0</option>
        <option value="alt1">Alt1</option>
    </select>

    <table id="variable-description-table">
        <thead>
            <tr>
                <th>Variable</th>
                <th>Name</th>
                <th>Description</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody id="variable-description-table-body">
            <tr id="state-row">
                <td id="state"></td>
                <td id="state-name"></td>
                <td id="state-description"></td>
                <td id="state-example"></td>
            </tr>
            <tr id="state-transition-matrix-row">
                <td id="state-transition-matrix"></td>
                <td id="state-transition-matrix-name"></td>
                <td id="state-transition-matrix-description"></td>
                <td id="state-transition-matrix-example"></td>
            </tr>
            <tr id="state-covariance-row">
                <td id="state-covariance"></td>
                <td id="state-covariance-name"></td>
                <td id="state-covariance-description"></td>
                <td id="state-covariance-example"></td>
            </tr>
        </tbody>
    </table>

    <p id="state-model"></p>
    <!-- <p id="measurement-model"></p> -->

    <script>
        let currently_hovered_elements = []; // contains {element, color} pairs
        function highlight_smallest_width_element() {
            // find the currently_hovered_element with the smallest width
            let smallest_width = Infinity;
            let smallest_width_element = null;
            for (const el_color_pair of currently_hovered_elements) {
                if (el_color_pair.element.offsetWidth < smallest_width) {
                    smallest_width = el_color_pair.element.offsetWidth;
                    smallest_width_element = el_color_pair.element;
                }
            }
            for (const el_color_pair of currently_hovered_elements) {
                if (el_color_pair.element === smallest_width_element) {
                    el_color_pair.element.style.backgroundColor = el_color_pair.color;
                }
                else {
                    el_color_pair.element.style.backgroundColor = '';
                }
            }
        }

        class FormulaElement {
            constructor(div_name,
                        display_name, 
                        description, 
                        example, 
                        convention_to_latex,
                        child_elements = [],
                        color = 'rgba(255, 255, 0, 0.8)') {
                this.div_name = div_name; // eg. state-model
                this.display_name = display_name; // eg. State Model Equation
                this.description = description; 
                this.example = example;
                this.convention_to_latex = convention_to_latex; // eg. alt0 (affects how string is rendered)
                this.convention = Object.keys(convention_to_latex)[0];
                this.child_elements = child_elements;
                this.color = color;
            }

            create_tooltip() {
                this.tooltip = tippy(`[class="${this.div_name}"]`, {
                    content: this.description,
                    animation: 'scale',
                    theme: 'light',
                    // trigger: 'click',
                    placement: 'auto',
                });
            }

            create_highlight() {
                const elements = document.querySelectorAll(`[class="${this.div_name}"]`);
                for (const el of elements) {
                    el.addEventListener('mouseenter', (event) => {
                        currently_hovered_elements.push({element: el, color: this.color});
                        highlight_smallest_width_element();

                    });

                    el.addEventListener('mouseleave', (event) => {
                        el.style.backgroundColor = '';
                        // Remove this element from the currently_hovered_elements array
                        currently_hovered_elements = currently_hovered_elements.filter(el_color_pair => el_color_pair.element !== el);
                        highlight_smallest_width_element();
                    });
                }
            }

            update_naming_convention(convention) {
                if (this.convention !== 'all') {
                    if (this.convention_to_latex.hasOwnProperty(convention)) {
                        this.convention = convention;
                    }
                    else {
                        console.log(`Naming convention ${convention} not found for ${this.div_name}`);
                    }
                }
                for (const child of Object.values(this.child_elements)) {
                    child.update_naming_convention(convention);
                }
            }

            str(delimiter="") {
                const string_fn = this.convention_to_latex[this.convention];
                return `${delimiter}\\class{${this.div_name}}{${string_fn(this.child_elements)}}${delimiter}`;
            }
        }

        const variables = {
            state: new FormulaElement("state", 
                "State",
                "The state of the system", 
                "The position and velocity of a moving object", 
                {'alt0': (v) => `\\mathbf{x}`,
                 'alt1': (v) => `\\mathbf{s}`},
                [],
                'rgba(0, 255, 0, 0.8)'
            ),
            state_transition: new FormulaElement("state-transition-matrix", 
                "State Transition Matrix", 
                "The matrix that transforms the state estimate to the next state", 
                "Velocity matrix",
                {'alt0': (v) => `\\mathbf{F}`,
                 'alt1': (v) => `\\mathbf{A}`},
                [],
                'rgba(255, 0, 0, 0.8)'
            ),
            state_covariance: new FormulaElement("state-covariance", 
                "State Covariance", 
                "The covariance of the state estimate", 
                "The uncertainty in the state estimate",
                {'all': (v) => `\\mathbf{P}`},
                [],
                'rgba(0, 0, 255, 0.8)'
            ),
        }

        // All of the formulas that should be wrapped in $$ and typeset
        const formulas = {
            state_model: new FormulaElement("state-model", 
                "State Model",
                "The state model of the system", 
                "The position and velocity of a moving object", 
                {"all": (v) => `${v.state.str()}_t = ${v.state_transition.str()} ${v.state.str()}_{t-1}`},
                variables,
                'rgba(255, 155, 0, 0.8)'
            )
        }

        // Fill in all divs with formulas according to the naming convention
        function set_naming_convention(convention) {
            let elements_to_typeset = [];
            for (const object of [...Object.values(formulas), ...Object.values(variables)]) {
                const formulaDiv = document.getElementById(object.div_name);
                object.update_naming_convention(convention);
                formulaDiv.innerHTML = object.str("$$");
                elements_to_typeset.push(formulaDiv);
            }
            return elements_to_typeset;
        }

        // Fill in all divs with non-formula text descriptions
        function set_text_descriptions() {
            for (const object of [...Object.values(formulas), ...Object.values(variables)]) {
                display_div = document.getElementById(`${object.div_name}-name`);
                if (display_div) {
                    display_div.textContent = object.display_name;
                }
                description_div = document.getElementById(`${object.div_name}-description`);
                if (description_div) {
                    description_div.textContent = object.description;
                }

                example_div = document.getElementById(`${object.div_name}-example`);
                if (example_div) {
                    example_div.textContent = object.example;
                }
            }
        }

        // safe version of MathJax.typesetPromise that doesn't throw an error when MathJax is not yet loaded,
        // creates tooltips, and logs errors
        function safeTypesetPromise(elements_to_typeset) {
            MathJax.startup.promise = MathJax.startup.promise
                .then(() => {
                    MathJax.typesetPromise(elements_to_typeset);
                    console.log("MathJax Typeset success");
                    create_tooltips([...Object.values(formulas), ...Object.values(variables)]);
                    create_highlights([...Object.values(formulas), ...Object.values(variables)]);
                })
                .catch((err) => console.log('MathJax typeset() failed: ' + err.message));
            return MathJax.startup.promise;
        }

        set_naming_convention('alt0');
        set_text_descriptions();
        // calling the typeset function here fails because MathJax is not defined yet. 
        // It's ok to not call it because by default, MathJax waits for the HTML to load 
        // (including the set_naming_convention() function which fills in all the divs)
        // and then typesets the entire page and then adds tooltips.
        // safeTypesetPromise();

        document.getElementById('naming-convention').addEventListener('change', function(event) {
            const convention = event.target.value;
            elements_to_typeset = set_naming_convention(convention);
            safeTypesetPromise(elements_to_typeset);
        });

    </script>
</body>
</html>