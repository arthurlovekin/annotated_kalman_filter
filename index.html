<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Interactive Kalman Filter</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://unpkg.com/@popperjs/core@2"></script>
    <script src="https://unpkg.com/tippy.js@6"></script>

    <script src="js/draggable-number.js"></script>
    <script src="js/gaussian-functions.js"></script>
    <script src="js/formula-element.js"></script>
    <script src="js/formula-element-definitions.js"></script>
    <script src="js/mouse-effects-manager.js"></script>
    <script src="js/expandable-content.js"></script>
    <script src="js/kalman-filter-functions.js"></script>
    <script>
        const mouseEffectsManager = new MouseEffectsManager([...Object.values(variables)]);
    </script>
    <script src="js/mathjax-dynamic-initialization.js"></script>
    <script id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>
    <link rel="stylesheet" href="css/style.css">
</head>

<body>
    <h1>The Interactive Kalman Filter</h1>

    <div>
        <div id="intro-animation">    
            <div class="animation-container">
                <!-- SVG Robot -->
                <svg
                    width="78.827438mm"
                    height="90.709648mm"
                    viewBox="0 0 78.827438 90.709648"
                    version="1.1"
                    class="animation-robot"
                    xml:space="preserve"
                    xmlns="http://www.w3.org/2000/svg"
                    xmlns:svg="http://www.w3.org/2000/svg"><defs
                    class="defs1" /><g
                    class="body-layer"
                    transform="translate(-22.948456,-89.841802)"><path
                        style="opacity:0.99;fill:#a9c2ff;stroke:#858585;stroke-width:0.315"
                        d="m 60,90 c 9.621514,-0.06872 27.937315,4.966259 35,20 4.885644,8.69531 7.13726,41.14576 3.852748,47.30871 -3.130752,5.87445 -32.595817,6.76909 -39.141815,6.62609 -5.654366,-0.0512 -28.523962,0.63944 -31.397083,-7.34956 -3.240816,-11.23592 6.026113,-21.40713 7.734165,-41.25892 C 36.681208,107.96705 32.12253,92.455092 60,90 Z"
                        class="body-blob" /><circle
                        style="opacity:0.99;fill:#dcdffc;fill-opacity:1;stroke:#858585;stroke-width:0.315"
                        class="eye-white"
                        cx="77.621758"
                        cy="111.97367"
                        r="9.547823" /><circle
                        style="opacity:1;fill:#0f113f;fill-opacity:1;stroke:#020202;stroke-width:0.495001;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                        class="eye-pupil"
                        cx="77.621758"
                        cy="111.97367"
                        r="2.6847837" /><g
                        class="ultrasonic-group"
                        transform="matrix(0.46871921,0,0,0.46871921,-27.37283,72.641369)"><path
                        class="rect6"
                        style="opacity:1;fill:#0f113f;fill-opacity:1;stroke:#858585;stroke-width:0.495001;stroke-linecap:square"
                        d="m 127.17951,61.399733 12.57342,10.103943 -0.0408,63.504364 -12.50358,-10.33231 z" /><g
                        class="ultrasonic-cylinder-1"><path
                            class="rect5"
                            style="opacity:1;fill:#bcc2cf;fill-opacity:1;stroke:#858585;stroke-width:0.495;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none"
                            d="m 121.33471,71.751176 c -0.48654,0 -0.8785,0.391438 -0.8785,0.877983 v 20.853507 c 0,0.486545 0.39196,0.877983 0.8785,0.877983 h 11.71867 v 0 c 2.05411,-6.42e-4 4.84521,-5.137415 4.84518,-11.304737 3e-5,-6.167322 -2.79107,-11.304094 -4.84518,-11.304736 v 0 z" /><ellipse
                            style="opacity:0.99;fill:#25282e;fill-opacity:1;stroke:#858585;stroke-width:0.769677"
                            class="path3"
                            cx="120.45645"
                            cy="83.1931"
                            rx="3.719537"
                            ry="11.167632" /></g><g
                        class="ultrasonic-cylinder-2"><path
                            class="path7"
                            style="opacity:1;fill:#bcc2cf;fill-opacity:1;stroke:#858585;stroke-width:0.495;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none"
                            d="m 121.33471,100.66893 c -0.48654,0 -0.8785,0.39144 -0.8785,0.87799 v 20.8535 c 0,0.48655 0.39196,0.87799 0.8785,0.87799 h 11.71867 v 0 c 2.05411,-6.4e-4 4.84521,-5.13742 4.84518,-11.30474 3e-5,-6.16732 -2.79107,-11.30409 -4.84518,-11.30474 v 0 z" /><ellipse
                            style="opacity:0.99;fill:#25282e;fill-opacity:1;stroke:#858585;stroke-width:0.769677"
                            class="ellipse7"
                            cx="120.45645"
                            cy="112.11086"
                            rx="3.719537"
                            ry="11.167632" /></g></g></g><g
                    class="wheel-layer"
                    transform="translate(-22.948456,-89.841802)"><g
                        class="front-wheel"
                        style="display:inline"
                        transform="translate(-49.063398,7.483203)"><circle
                        style="opacity:1;fill:#121212;fill-opacity:1;stroke:#020202;stroke-width:0.495001;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                        class="axle1"
                        cx="134.39388"
                        cy="156.62283"
                        r="1.7787484" /><circle
                        style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:4;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                        class="front-tire"
                        cx="134.39388"
                        cy="156.62283"
                        r="14.445418" /><circle
                        style="fill:none;fill-opacity:1;stroke:#020202;stroke-width:2.17772;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                        class="path9-9"
                        cx="134.39388"
                        cy="156.62283"
                        r="9.6793108" /><circle
                        style="fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                        class="circle9"
                        cx="134.39388"
                        cy="156.62283"
                        r="3.6967146" /><g
                        class="front-spokes-1"><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 134.39387,152.92612 v -5.9826"
                            class="path10" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 138.09059,156.62283 h 5.98259 v 0"
                            class="path11" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 134.39387,160.31955 v 5.98259"
                            class="path12" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 130.69716,156.62283 h -5.9826"
                            class="path13" /></g><g
                        class="front-spokes-2"
                        transform="rotate(45,134.39387,156.62284)"><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 134.39387,152.92612 v -5.9826"
                            class="path17" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 138.09059,156.62283 h 5.98259 v 0"
                            class="path18" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 134.39387,160.31955 v 5.98259"
                            class="path19" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 130.69716,156.62283 h -5.9826"
                            class="path20" /></g></g><g
                        class="rear-wheel"
                        style="display:inline"
                        transform="translate(-95,7.483203)"><circle
                        style="opacity:1;fill:#121212;fill-opacity:1;stroke:#020202;stroke-width:0.495001;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                        class="axle2"
                        cx="134.39388"
                        cy="156.62283"
                        r="1.7787484" /><circle
                        style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:4;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                        class="circle36"
                        cx="134.39388"
                        cy="156.62283"
                        r="14.445418" /><circle
                        style="fill:none;fill-opacity:1;stroke:#020202;stroke-width:2.17772;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                        class="circle37"
                        cx="134.39388"
                        cy="156.62283"
                        r="9.6793108" /><circle
                        style="fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                        class="circle38"
                        cx="134.39388"
                        cy="156.62283"
                        r="3.6967146" /><g
                        class="g41"><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 134.39387,152.92612 v -5.9826"
                            class="path38" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 138.09059,156.62283 h 5.98259 v 0"
                            class="path39" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 134.39387,160.31955 v 5.98259"
                            class="path40" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 130.69716,156.62283 h -5.9826"
                            class="path41" /></g><g
                        class="g45"
                        transform="rotate(45,134.39387,156.62284)"><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 134.39387,152.92612 v -5.9826"
                            class="path42" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 138.09059,156.62283 h 5.98259 v 0"
                            class="path43" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 134.39387,160.31955 v 5.98259"
                            class="path44" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 130.69716,156.62283 h -5.9826"
                            class="path45" /></g></g></g>
                    </svg>
            </div>
            <table class="math-diagram-structure-table">
                <tr>
                    <td>Control the robot's acceleration by dragging the number: \( \controlInput = \)</td>
                    <td>
                        <table class="matrix-table">
                            <tr>
                                <td>
                                    <draggable-number class="control-input-slider" min="-1" max="1" value="0.1" step="0.1"></draggable-number>
                                </td>
                            </tr>
                        </table>
                    </td>
                </tr>
                <tr>
                    <td>
                        <button class="start-button">Start</button>
                        <button class="stop-button">Stop</button>
                        <button class="reset-button">Reset</button>
                    </td>
                </tr>
            </table>
        </div>
            <script>
                (function() {
                const diagram = document.getElementById('intro-animation');
                // Also need to change the Plotly id
                const robot = diagram.querySelector('.animation-robot');
                const slider = diagram.querySelector('.control-input-slider');
                const container = diagram.querySelector('.animation-container');
                const startButton = diagram.querySelector('.start-button');
                const stopButton = diagram.querySelector('.stop-button');
                const resetButton = diagram.querySelector('.reset-button');
    
                /////////////////////////////////////////////////////////////
                // Kalman Filter parameters + models
                const wheelRadius = 50; //px (didn't actually measure this)
                const maxVelocity = 400; //px/sec
                const maxAngularAcceleration = 5; //rad/sec^2
                const KF_dt_min = 0.2; //seconds (determines how often the Predict step runs)
                const meas_dt_min = 0.5; //seconds (determines how often the Update step runs)
    
                // Truestate variables
                let throttle;  // -1 to 1
                let x; //px/s
    
                // Estimated state variables
                let x_est;
                let P_est;
    
                function resetAllVariables() {
                    // Truestate variables
                    throttle = parseFloat(slider.value);  // -1 to 1
                    x = [[0], //px
                        [100]]; //px/s
    
                    // Estimated state variables
                    const initial_state_variance = 100;
                    x_est = x;
                    P_est = [[initial_state_variance,0],[0,initial_state_variance]];
                }
                resetAllVariables();
    
                /////////////////////////////////////////////////////////////
                /////////////////////////////////////////////////////////////
    
                // Pupil animation
                const frontWheel = robot.querySelector('.front-wheel');
                const rearWheel = robot.querySelector('.rear-wheel');
                const pupil = robot.querySelector('.eye-pupil');
                const eyeWhite = robot.querySelector('.eye-white');
    
                function updatePupilPosition(mouseX, mouseY) {
                    const eyeWhiteRect = eyeWhite.getBoundingClientRect();
                    const pupilRect = pupil.getBoundingClientRect();
                    // Calculate the center of the eye
                    const eyeCenterX = eyeWhiteRect.left + eyeWhiteRect.width / 2;
                    const eyeCenterY = eyeWhiteRect.top + eyeWhiteRect.height / 2;
        
                    // Calculate the angle between the eye center and the mouse position
                    const angle = Math.atan2(mouseY - eyeCenterY, mouseX - eyeCenterX);
                    const distance = Math.sqrt((mouseX - eyeCenterX) * (mouseX - eyeCenterX) + (mouseY - eyeCenterY) * (mouseY - eyeCenterY));
        
                    // Calculate the maximum distance the pupil can move from the center
                    const maxDistance = (eyeWhiteRect.width - pupilRect.width) / 2;
        
                    // Calculate the new position of the pupil
                    let pupilX = Math.cos(angle) * Math.min(distance, maxDistance);
                    let pupilY = Math.sin(angle) * Math.min(distance, maxDistance);
                    
                    // Apply the new position to the pupil
                    pupil.style.transform = `translate(${pupilX}px, ${pupilY}px)`;
                }
        
                // Add event listener for mouse movement
                container.addEventListener('mousemove', (e) => {
                    updatePupilPosition(e.clientX, e.clientY);
                });
    
                // Update velocity when the slider value changes
                slider.addEventListener('input', () => {
                    throttle = parseFloat(slider.value);
                });
    
                ///// Animation Start/Stop Controls /////
                // Stop running the animation when the user can't see it
                let animationRunning = true;
                function startAnimation() {
                    animationRunning = true;
                    requestAnimationFrame(animateRobot);
                }
                function stopAnimation() {
                    animationRunning = false;
                }
                function resetAnimation() {
                    resetAllVariables();
                    renderAnimation(x);
                }
                // Stop running when the user can't see the animation
                function handleIntersection(entries) {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            startAnimation();
                        } else {
                            stopAnimation();
                        }
                    });
                }
                const observer = new IntersectionObserver(handleIntersection, {
                    root: null, // Use the viewport as the root
                    threshold: 0.1 // Trigger when 10% of the element is visible
                });
                observer.observe(container);
    
                // Start/Stop/Reset buttons
                startButton.addEventListener('click', () => {
                    startAnimation();
                });
                stopButton.addEventListener('click', () => {
                    stopAnimation();
                });
                resetButton.addEventListener('click', () => {
                    resetAnimation();
                });
    
                function renderAnimation(x) {
                    const wheelRotation = positiveModulo(x[0][0]/wheelRadius * 180/Math.PI, 360);
        
                    // Apply the new position and wheel rotation to the robot
                    const pixel_position = positiveModulo(x[0][0], container.clientWidth + 2*robot.clientWidth) - robot.clientWidth;
                    robot.style.left = `${pixel_position}px`;
                    // In the SVG the front wheel was originally drawn centered at 134.39388px 156.62283px
                    // then the whole front wheel was translated by -47.066795px, 7.9443462px
                    // We need to rotate the wheel about its translated center
                    frontWheel.style.transformOrigin = `${134.39388 - 47.066795}px ${156.62283 + 7.9443462}px`;
                    frontWheel.style.transform = `rotate(${wheelRotation}deg) translate(-47.066795px, 7.9443462px)`;
        
                    // In the SVG the rear wheel was originally drawn centered at 134.39388px 156.62283px
                    // then the whole rear wheel was translated by -95px, 7.9443462px
                    // We need to rotate the wheel about its translated center
                    rearWheel.style.transformOrigin = `${134.39388 - 95}px ${156.62283 + 7.9443462}px`;
                    rearWheel.style.transform = `rotate(${wheelRotation}deg) translate(-95px, 7.9443462px)`;
                }
    
                let t_prev;
                function animateRobot(timestamp) {
                    if (!animationRunning) {
                        t_prev = undefined;
                        return;
                    }
                    if (timestamp === undefined) {
                        console.error('animateRobot: timestamp is undefined. Ensure that animateRobot is being called by requestAnimationFrame or otherwise being passed a timestamp.');
                    }
                    if (t_prev === undefined) {
                        t_prev = timestamp;
                    }
                    // True state
                    const dt = (timestamp - t_prev) / 1000;
                    t_prev = timestamp;
                    x = trueStateModel(x, dt, throttle, wheelRadius, maxVelocity, maxAngularAcceleration);
    
                    renderAnimation(x);
                    requestAnimationFrame(animateRobot);
                }
        
                // Start the animation
                updatePupilPosition(450,170);
                requestAnimationFrame(animateRobot);
    
                })();
            </script>
    </div>
    <h2>Introduction</h2>
    <p>The Kalman Filter is a powerful tool for combining information in the face
    of uncertainty, and is used widely throughout science and engineering for
    tracking time-varying systems. In this article, I hope to teach you how deep
    principles in probability and linear algebra (which you probably already
    know!) naturally lead to the equations of the Kalman Filter. I've made a
    series of interactive diagrams that will give you a better feel for the
    different parameters, and help you understand both the power and limitations
    of this method.</p>

    <p>This is meant as an introduction that can kickstart your progress without
    having to digest an entire math textbook. That being said, the theory behind
    the Kalman Filter goes a lot deeper than what I show here, including
    theoretical proofs of optimality and extensions to nonlinear systems. At the 
    end of the article, I've listed the resources I used to write this article,
    which I highly recommend if you want to dive deeper.</p>

    <p>There are over 17 variables that are commonly used to derive the Kalman
    Filter, and to make matters more confusing many resources use different
    naming conventions! To alleviate this pain, I've made it so that you can
    choose the naming convention using the dropdown menu below. Also, you can
    click on any variable throughout the article to get more information about
    it.</p>
    </p>
    <div style="text-align: center;">
        Choose your naming convention: 
        <select id="naming-convention-dropdown">
            <option value="wikipedia">Wikipedia</option>
            <option value="kalmanfilterdotnet">KalmanFilter.net</option>
        </select>
    </div>

    <h3>What is the Kalman Filter?</h3>
    <p>
    The primary goal of the Kalman Filter is to estimate the state of a dynamical
    system. The need for state estimation shows up throughout engineering. To
    give a few examples, if you're driving a car, you need to know where you are
    and how fast you're going before you can intelligently turn the steering
    wheel. If you're controlling the central heating in an office building, it
    is helpful to know the temperature in each room. If you're designing a
    brain-computer interface for paralyzed people, your entire aim might be to
    estimate the intended position of a cursor on a screen based on their noisy
    neural signals.
    </p>
    <p>
    In all of these cases, there are multiple sources of information that we
    can use to estimate the state of the system. On one hand, we have some 
    background knowledge of how the system should generally behave (eg. the 
    dynamical model of the car, building, or brain). On the other hand we 
    have sensors (eg. cameras, thermometer, or brain electrodes), that can 
    measure some aspect of the state. The challenge is that neither of 
    these information sources is perfect: our dynamical model doesn't account 
    for common disturbances, and although we often have many sensors, they 
    are usually noisy, contradictory, and cannot individually
    perceive the full state. To get the most reliable state estimate, we 
    need to continuously combine the information from the sensors and the 
    dynamical model as time progresses. 
    </p>
    <p>
    The Kalman Filter is an algorithm that incorporates new pieces of 
    information as they come in over time into one unified state estimate. 
    It does this in two steps:
    <ol>
        <li><strong>Predict</strong> the next state using the dynamical model</li>
        <li><strong>Update</strong> the state estimate using sensor measurements</li>
    </ol>
    The Kalman Filter assumes that both of the above steps can be described
    with linear models, and that there is some gaussian random noise
    associated with each of them. Under these assumptions, the Kalman Filter
    has been proven to be the theoretically optimal way to estimate the
    state of the system. Even when these assumptions don't hold, the Kalman Filter
    is still highly accurate and is also very memory-efficient and fast, so it is 
    a popular choice for many applications.
    </p>

    <h2>Building a model</h2>
    <p>To understand the details of the Kalman Filter, we'll use the example
        of a simple robot. The goal will be to estimate the position and velocity
        of the robot so that it can navigate without crashing. On its back, the 
        robot carries an ultrasonic sensor that can measure the distance to the 
        nearest wall, and you as the operator will be able to control the acceleration.
    </p>
    <div style="text-align: center;">
        <img src="./assets/Robot.svg" alt="A simple robot" style="width: 15%;">
    </div>
    <p> TODO: Play around with our state-space representation of the robot!</p>

    <p>The first step in building an engineering model is to define a state vector.
        For our robot, this will be a two-dimensional vector containing the \(p\) 
        and velocity \(v\). In general, the state vector simply contains the minimum set
        of variables needed to make a complete description of the system (so in other 
        examples it might contain things like temperatures, voltages, etc.). One caviat
        is that practically speaking, the Kalman Filter algorithm will only ever be able to 
        estimate the state, not work with the true state values. For this reason, 
        we'll add a little hat to indicate that this vector is just an estimate.
        $$ \text{Estimated State vector }\stateEstimate = \begin{bmatrix} p \\ v \end{bmatrix} 
            = \begin{bmatrix} \text{position} \\ \text{velocity} \end{bmatrix} $$
    </p>
    <p> Once we've defined our state vector, we need to model how it evolves over time.
    For our robot, we can use a simple kinematics formula:
    $$ \begin{alignat}{3}
        p_{\discreteTime} &= p_{\discreteTime-1} &+& \Delta t &v_{\discreteTime-1} \\
        v_{\discreteTime} &= 0                   &+&          &v_{\discreteTime-1} \\
        \end{alignat}
    $$
    </p>
    <p>We'll package this up into matrix form so it is easy to use later.
        We'll call the matrix that converts from the old state to a new state 
        using the dynamics model the state transition matrix \(\stateTransition\).

        $$ \text{State Transition Matrix } \stateTransition = \begin{bmatrix} 1 & \Delta t \\ 0 & 1 \end{bmatrix} $$
        $$
        \stateEstimate_{\discreteTime} = \stateTransition \stateEstimate_{\discreteTime-1} \\
        $$
    </p>
    <p>
        Now we have a simple dynamical model of our robot, but it fails to include one
        common thing: a way to control the robot. In the interactive demo above, you
        (as the operator) are able to control the linear acceleration \(a\) via the control input
        vector \(\controlInput\). This [-1,1] throttle input doesn't directly control the 
        linear acceleration, but rather dictates the angular acceleration of the wheels. 
        If we assume that the wheel has radius \(r\), the maximum angular acceleration 
        is \( \alpha_{\text{max}} \), and that the wheel perfectly tracks the control 
        command, then we can extend our kinematics equation to include the control input:
        $$ \begin{alignat}{3}
        a &= r \alpha_{\text{max}} u \\
        p_{\discreteTime} &= p_{\discreteTime-1} &+& \Delta t &v_{\discreteTime-1} &+& \frac{1}{2} (r \alpha_{\text{max}} u) \Delta t^2 \\
        v_{\discreteTime} &= 0                   &+&          &v_{\discreteTime-1} &+& (r \alpha_{\text{max}} u ) \Delta t \\
        \end{alignat}
        $$

        As with the state equation, we'll package this up in matrix form by defining
        the control matrix \(\controlMatrix\), which determines how the input 
        vector \(\controlInput \) impacts the state.

        $$ \text{Control Input Vector } \controlInput = \begin{bmatrix} u \end{bmatrix} $$

        $$ \text{Control Matrix } \controlMatrix = \begin{bmatrix} \frac{1}{2} r \alpha_{\text{max}} \Delta t^2 \\ r \alpha_{\text{max}} \Delta t \end{bmatrix} $$
        
        Combining this with our dynamics model, our complete dynamical model looks like this:

        $$
        \stateEstimate_{\discreteTime} = \stateTransition \stateEstimate_{\discreteTime-1} + \controlMatrix \controlInput_{\discreteTime} \\
        $$

        In summary, we <it>predict</it> the new state by applying the dynamics model to the previous state estimate, and adding 
        a correction term for known influences like the control input. 
    </p>

    <p class="expandable-content-text" onclick="toggleExpandableContent('controlling-velocity')">
        What if I'm controlling something other than the acceleration (like the velocity)?
    </p>
    <div class="expanded-content" id="controlling-velocity"> 
        The model above is there for your convenience, but if your system is different you should 
        feel free to modify it!
        For example, a velocity controller might assume that the control input directly 
        dictates the velocity, which would give you the following matrices:
        $$ \text{Control Input Vector } \controlInput = \begin{bmatrix} v \end{bmatrix} $$
        $$ \text{Control Matrix } \controlMatrix = \begin{bmatrix} 0 \\ 1 \end{bmatrix} $$
        $$ \text{State Transition Matrix } \stateTransition = \begin{bmatrix} 1 & \Delta t \\ 0 & 0 \end{bmatrix} $$
    (Note that \(\stateTransition\) now has zeros in the bottom row because it is more reliable 
    to assume that the controller dictates the new velocity than that the velocity remains constant.)
    There are other possibilities: you could get rid of \( \controlMatrix \) entirely and 
    make \(\stateTransition_{11} = \frac{u}{v}\), or you could even treat the 
    control input as a sensor and incorporate it in the Update step (see below). I don't know what is best, 
    but you should experiment with what makes sense!
    
    </div>

 
    <h2>Bringing Uncertainty into the Model</h2>
    <p>
        The linear model we derived above is great, but it's not very realistic.
        In the real world, the robot might slip and bounce over the terrain, the motors might not
        exactly reach the commands. In other words, there is random noise introduced by the 
        messiness of the environment, which in turn makes our state estimate less certain.
    </p>
    <p>
        One method that can represent both the uncertainty in our state estimate 
        and the random noise introduced by the environment is to assign each of them a 
        probability distribution. For simplicity, we assume that both of these distributions are gaussian.
    </p>
    <p> So now, instead of representing our state estimate with a single vector, we'll say that our state estimate 
        is a normal distribution parametrized by a mean \(\state\) and a covariance \(\stateCovariance\).
        $$ \stateEstimate \sim \gaussian \left( \state, \stateCovariance \right) $$
    </p>

    <div id="interactive-gaussian-3d-figure">
        <div style="border: 1px solid #000; border-radius: 5px; padding: 2px;">
            <table id="gaussian-3d-figure" class="math-diagram-structure-table">
                <tr>
                    <td>
                        <div id="gaussian-3d-plot"></div>
                    </td>
                </tr>
                <tr>
                    <td>
                        <table class="math-diagram-structure-table">
                            <tr>
                                <td>\( \mathcal{N} \left( 
                                    \begin{eqnarray}
                                    \\
                                    \state\\
                                    \\
                                \end{eqnarray}
                                \right. =\)
                                <td>
                                    <table class="matrix-table">
                                        <tr>
                                            <td>
                                                <draggable-number class="draggable-x0" min="-3" max="3" step="0.01" value="1">1.0</draggable-number>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>
                                                <draggable-number class="draggable-x1" min="-3" max="3" step="0.01" value="1">1.0</draggable-number>
                                            </td>
                                        </tr>
                                    </table>
                                </td>
                                <td>, \( \stateCovariance = \)</td>
                                <td>
                                    <table class="matrix-table">
                                        <tr>
                                            <td>
                                                <draggable-number class="draggable-P00" min="0.01" max="5" step="0.01" value="1">1.0</draggable-number>
                                            </td>
                                            <td>
                                                <draggable-number class="draggable-P01" min="-5" max="5" step="0.01" value="0.0">0.0</draggable-number>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>
                                                <div class="dynamic-number-container draggable-P10">0.0</div>
                                            </td>
                                            <td>
                                                <draggable-number class="draggable-P11" min="0.01" max="5" step="0.01" value="1">1.0</draggable-number>
                                            </td>
                                        </tr>
                                    </table>
                                </td>
                                <td>\( \left. 
                                        \begin{eqnarray}
                                        \\
                                        \\
                                        \\
                                    \end{eqnarray}
                                    \right) \)
    
                            </tr>
                        </table>
                    </td>
                </tr>
            </table>
        </div>
        <script>
            const figure = document.getElementById('gaussian-3d-figure');
            const x0 = figure.querySelector('.draggable-x0');
            const x1 = figure.querySelector('.draggable-x1');
            const P00 = figure.querySelector('.draggable-P00');
            const P01 = figure.querySelector('.draggable-P01');
            const P10 = figure.querySelector('.draggable-P10');
            const P11 = figure.querySelector('.draggable-P11');
    
            // Make the covariance be positive semi-definite and symmetric
            P00.setValidityCondition((newValue) => {
                return isPositiveSemiDefinite([[newValue, P01.value], [P01.value, P11.value]])
            });
            P01.setValidityCondition((newValue) => {
                return isPositiveSemiDefinite([[P00.value, newValue], [newValue, P11.value]])
            });
            P11.setValidityCondition((newValue) => {
                return isPositiveSemiDefinite([[P00.value, P01.value], [P01.value, newValue]])
            });
    
            const plotLayout = {
                title: 'Bivariate Gaussian Distribution',
                scene: {
                    xaxis: { 
                        title: 'Position',
                        range: [-3, 3]
                    },
                    yaxis: { 
                        title: 'Velocity',
                        range: [-3, 3]
                    },
                    zaxis: { 
                        title: 'Probability',
                    },
                    // camera: {
                    //     eye: { x: 0, y: 0, z: 2 },
                    //     up: { x: 0, y: 1, z: 0 },
                    //     center: { x: 0, y: 0, z: 0 }
                    // }
                },
            }
    
            function generateGaussianBasePts(mu, sigma, n_points, min, max) {
                // generate n_points that extend either to 3 sigma or to min and max 
                return linspace(Math.min(min, mu-3*sigma), Math.max(max, mu+3*sigma), n_points);
            }
            const n_points = 41;
            const xPts = linspace(-3,3,n_points); // generateGaussianBasePts(x0.value, P00.value, n_points, -3, 3);
            const yPts = linspace(-3,3,n_points); //generateGaussianBasePts(x1.value, P11.value, n_points, -3, 3);
    
            function updateGaussian3dPlot() {
                const x = [[x0.value], [x1.value]];
                // Note: P01 used instead of P10 because the matrix is symmetric
                const P = [[P00.value, P01.value], [P01.value, P11.value]];
    
                P10.textContent = P01.value.toFixed(2); //symmetric matrix
                const zPts = generate3dGaussianSurface(x, P, xPts, yPts);
                // const x_proj = univariateGaussianXYpts(x0.value, P00.value, xAbsMin=-3, xAbsMax=3, yAbsMax=1.5, numPts=80);
                // const y_proj = univariateGaussianXYpts(x1.value, P11.value, xAbsMin=-3, xAbsMax=3, yAbsMax=1.5, numPts=80);
    
                let trace = {
                    x: xPts,
                    y: yPts,
                    z: zPts,
                    type: 'surface',
                    showscale: false,  // This line removes the colorbar
                    contours: {
                        z: {
                            show: true,
                            usecolormap: true,
                            project: {z: true}
                        },
                    },
                    legend: {
                        show: false
                    },
                    hovermode: false,
                    hoverinfo: 'none',
                    hoverlabel: {bgcolor: 'rgba(0,0,0,0)'},  // This makes hover labels transparent
                    clickmode: 'none',
                };
    
                Plotly.react("gaussian-3d-plot", [trace], plotLayout);
            }
            updateGaussian3dPlot();
    
            [x0, x1, P00, P01, P11].forEach((element) => {
                element.addEventListener('input', updateGaussian3dPlot);
            });
    
        </script>
    </div>

    <p class="expandable-content-text" onclick="toggleExpandableContent('why-a-gaussian')">
        Why a gaussian?
    </p>
    <div class="expanded-content" id="why-a-gaussian"> 
        There are a few really compelling reasons to choose a gaussian: 
        <ol>
            <li>We can parametrize the distribution with just the mean and variance, so it is numerically easy to update</li>
            <li>When we combine two independent gaussians into one estimate, the result is also a gaussian</li>
            <li>Mathematicians have proven (the Central Limit Theorem) that the combined effect of many random processes (even if individually they are non-gaussian)
                will result in a gaussian distribution</li>
        </ol>

        Take heed: we choose a gaussian mostly because it is numerically convenient, but in practice many things (even something as simple
        as a \( \sin \theta \) term in the dynamics model introduced by turning around), will make the distribution non-gaussian.
    </div>

    <p>
        Hopefully you're already familiar with a 1D normal distribution, which is usually parametrized by 
        its mean \(\mu\) and variance \(\sigma^2\). The multivariate version is similar, except now the 
        mean is an n-dimensional vector (in our case, 2-dimensional), and the covariance is an n x n matrix whose (\(i,j\))th element
        represents the covariance between the \(i\)th and \(j\)th state variables.
        $$ \text{Mean State Vector } \state = \begin{bmatrix} \bar{p} \\ \bar{v} \end{bmatrix} $$
        $$ \text{State Covariance Matrix } \stateCovariance = \begin{bmatrix} \text{Var}(p) & \text{Cov}(p,v) \\ \text{Cov}(v,p) & \text{Var}(v) \end{bmatrix} $$
    </p>
    
    <p>Now comes an important point: In our dynamics equation above we know how to apply the matrix \(\stateTransition\) 
        to the state estimate \( \stateEstimate \) when it was a single vector. But now our estimate is a gaussian,
        so we need to apply \(\stateTransition\) to the whole distribution. Fortunately, the mean is a single point,
        so we can directly apply the state transition matrix as we did before. The variance on the other hand is the 
        average "squared-distance" from the mean, so how should it be treated?
    </p>
    <p> We'll introduce a very useful rule for multiplying a gaussian distribution 
        \(\gaussian \left( \mathbf{\bar{\mu}}, \mathbf{\Sigma} \right) \) by a matrix \( \mathbf{A} \):
    </p>
    <p id="gaussian-multiplication-rule">
        $$
        \begin{align}
            \text{If you linearly transform the mean: } &
            \mathbf{\bar{\mu}}_{\discreteTime} = \mathbf{A} \mathbf{\bar{\mu}}_{\discreteTime-1} 
            \\
            \text{ then the covariance is: } &
            \mathbf{\Sigma}_{\discreteTime} = \mathbf{A} \mathbf{\Sigma}_{\discreteTime-1} \mathbf{A}^T
        \end{align}
        $$
    </p>
    <p class="expandable-content-text" onclick="toggleExpandableContent('why-multiply-covariance')">
        Why multiply the covariance by \( \mathbf{A} \) on the left and right?
    </p>
    <div class="expanded-content" id="why-multiply-covariance">
        One way you can remember this is to think back to what happens when you multiply a 1D normal distribution by a scalar.
        The standard deviation \( \sigma \) will scale linearly, and the variance is the standard deviation squared
        (which we can write in a way that is suggestive of what the operation looks like in higher dimensions).
        <div style="max-width: 100%; text-align: center;">
            <img src="./assets/variance-diagram-1d.png" alt="Diagram showing the effect of multiplying a 1D Gaussian by a scalar" style="max-width: 100%; height: auto;">
        </div>
    </div>

    <p> The other thing we need to know is that if we add or subtract two independent, normally distributed 
        random variables, then their variances add. (see 
        <a href="https://apcentral.collegeboard.org/courses/ap-statistics/classroom-resources/why-variances-add-and-why-it-matters" target="_blank" rel="noopener noreferrer"
        >AP Central's explanation</a>
        for a refresher.)
    </p>

    <p>With this knowledge of probability, we have actually arrived to the point where we can write out the first component of the Kalman Filter:
        the <strong>Predict Step</strong>! We'll define the covariance of the state estimate to be \(\stateCovariance\), and the mean to be \(\state\). 
        To handle environmental noise, we'll also add a noise term with mean 0 and covariance \(\processNoiseCovariance\). Writing this out, we have:
    </p>
    <p>The Predict Step:
        $$ \state_{\discreteTime} = \stateTransition \state_{\discreteTime-1} + \controlMatrix \controlInput_{\discreteTime} $$
        $$ \stateCovariance_{\discreteTime} = \stateTransition \stateCovariance_{\discreteTime-1} \stateTransition^T + \processNoiseCovariance $$
    where
    $$ \text{State Estimate Distribution }\stateEstimate \sim \gaussian \left( \state, \stateCovariance \right) $$
    and $$ \text{Process Noise} \sim \gaussian \left( 0, \processNoiseCovariance \right) $$
    </p>
    <p> 
        Fundamentally, the predict step describes how to <it>predict</it> the a new gaussian state estimate from the previous estimate, 
        based on our dynamical model of the system. 
    </p>
    <p>Drag the underlined values to see how they would affect one iteration of the dynamics model!</p>
    <div id="predict-step-diagram">
        <table class="math-diagram-structure-table">
            <tr>
                <td>
                    <div class="figure-plot" id="predict-step-plot"></div>
                </td>
            </tr>
            <tr>
                <td>
                    <table class="math-diagram-structure-table">
                        <tr>
                            <td class="next-state-gaussian-expr">$$\state_{\discreteTime}$$</td>
                            <td>=</td>
                            <td>$$\stateTransition$$</td>
                            <td class="previous-state-gaussian-expr">$$\state_{\discreteTime -1}$$</td>
                            <td>+</td>
                            <td>$$\controlMatrix$$</td>
                            <td>$$\controlInput_{\discreteTime}$$</td>
                            <td>+</td>
                            <td>$$\mathbf{0}$$</td>
                        </tr>
                        <tr>
                            <td>
                                <table class="matrix-table">
                                    <tr><td id="predict-step-new-x-mean-0">2.0</td></tr>
                                    <tr><td id="predict-step-new-x-mean-1">1.0</td></tr>
                                </table>
                            </td>
                            <td><strong>=</strong></td>
                            <td>
                                <table class="matrix-table">
                                    <tr>
                                        <td>    
                                            <draggable-number id="predict-step-F-00" min="0" max="2" step="0.01" value="1">1.00</draggable-number>
                                        </td>
                                        <td>
                                            <draggable-number id="predict-step-F-01" min="0" max="0.5" step="0.01" value="0.01">0.01</draggable-number>
                                        </td>
                                    </tr>
                                    <tr>
                                        <td>
                                            <draggable-number id="predict-step-F-10" min="-0.5" max="0.5" step="0.01" value="0.0">0.00</draggable-number>
                                        </td>
                                        <td>
                                            <draggable-number id="predict-step-F-11" min="0" max="2" step="0.01" value="1">1.00</draggable-number>
                                        </td>
                                    </tr>
                                </table>
                            </td>
                            <td>
                                <table class="matrix-table">
                                    <tr>
                                        <td>
                                            <draggable-number id="predict-step-x-mean-0" min="-3" max="3" step="0.01" value="0.0">0.00</draggable-number>
                                        </td>
                                    </tr>
                                    <tr>
                                        <td>
                                            <draggable-number id="predict-step-x-mean-1" min="-3" max="3" step="0.01" value="0.0">0.00</draggable-number>
                                        </td>
                                    </tr>
                                </table>
                            </td>
                            <td><strong>+</strong></td>
                            <td>
                                <table class="matrix-table">
                                    <tr>
                                        <td id="predict-step-B-00">0.00</td>
                                    </tr>
                                    <tr>
                                        <td id="predict-step-B-10">1.00</td>
                                    </tr>
                                </table>
                            </td>
                            <td>
                                <table class="matrix-table">
                                    <tr>
                                        <td>
                                            <draggable-number id="predict-step-u-0" min="0" max="1" step="0.01" value="0">0.00</draggable-number>
                                        </td>
                                    </tr>
                                </table>
                            </td>
                            <td><strong>+</strong></td>
                            <td>
                                <table class="matrix-table">
                                    <tr>
                                        <td id="predict-step-zero-0">0</td>
                                    </tr>
                                    <tr>
                                        <td id="predict-step-zero-1">0</td>
                                    </tr>
                                </table>
                            </td>
                        </tr>
                    </table>
                </td>
            </tr>
            <tr>
                <td>
    
                    <table class="math-diagram-structure-table">
                        <tr>
                            <td class="next-state-gaussian-expr">$$\stateCovariance_{\discreteTime}$$</td>
                            <td>=</td>
                            <td>$$\stateTransition$$</td>
                            <td class="previous-state-gaussian-expr">$$\stateCovariance_{\discreteTime - 1}$$</td>
                            <td>$$\stateTransition^T$$</td>
                            <td>+</td>
                            <td>$$\processNoiseCovariance$$</td>
                        </tr>
                        <tr>
                            <td>
                                <table class="matrix-table" id="predict-step-new-P">
                                    <tr>
                                        <td id="predict-step-new-P-sigma-00">0</td>
                                        <td id="predict-step-new-P-sigma-01">0</td>
                                    </tr>
                                    <tr>
                                        <td id="predict-step-new-P-sigma-10">0</td>
                                        <td id="predict-step-new-P-sigma-11">0</td>
                                    </tr>
                                </table>
                            </td>
                            <td><strong>=</strong></td>
                            <td>
                                <table class="matrix-table" id="predict-step-F-mirror1">
                                    <tr>
                                        <td id="predict-step-F-00-mirror1">1.00</td>
                                        <td id="predict-step-F-01-mirror1">0.00</td>
                                    </tr>
                                    <tr>
                                        <td id="predict-step-F-10-mirror1">0.00</td>
                                        <td id="predict-step-F-11-mirror1">1.00</td>
                                    </tr>
                                </table>    
                            </td>
                            <td>
                                <table class="matrix-table" id="predict-step-P">
                                    <tr>
                                        <td>
                                            <draggable-number id="predict-step-P-sigma-00" min="0" max="5" step="0.01" value="0.1">0.10</draggable-number>
                                        </td>
                                        <td>
                                            <draggable-number id="predict-step-P-sigma-01" min="-5" max="5" step="0.01" value="0">0.00</draggable-number>
                                        </td>
                                    </tr>
                                    <tr>
                                        <td id="predict-step-P-sigma-10">0.00</td>
                                        <td>
                                            <draggable-number id="predict-step-P-sigma-11" min="0" max="5" step="0.01" value="0.1">0.10</draggable-number>
                                        </td>
                                    </tr>
                                </table>
                            </td>
                            <td>
                                <table class="matrix-table" id="predict-step-F-mirror2">
                                    <tr>
                                        <td id="predict-step-F-00-mirror2">1.00</td>
                                        <td id="predict-step-F-01-mirror2">0.00</td>
                                    </tr>
                                    <tr>
                                        <td id="predict-step-F-10-mirror2">0.00</td>
                                        <td id="predict-step-F-11-mirror2">1.00</td>
                                    </tr>
                                </table>    
                            </td>
                            <td><strong>+</strong></td>
                            <td>
                                <table class="matrix-table" id="predict-step-Q">
                                    <tr>
                                        <td>
                                            <draggable-number id="predict-step-Q-00" min="0" max="5" step="0.01" value="0.1">0.10</draggable-number>
                                        </td>
                                        <td>
                                            <draggable-number id="predict-step-Q-01" min="-5" max="5" step="0.01" value="0">0.00</draggable-number>
                                        </td>
                                    </tr>
                                    <tr>
                                        <td id="predict-step-Q-10">0.00</td>
                                        <td>
                                            <draggable-number id="predict-step-Q-11" min="0" max="5" step="0.01" value="0.1">0.10</draggable-number>
                                        </td>
                                    </tr>
                                </table>
                            </td>
                        </tr>
                    </table>
                </td>
            </tr>
        </table>
    
        <script>
        (function() { // IIFE to prevent global scope pollution
            function updatePredictStepPlot(means, sigmas) {
                const layout = {
                    title: 'Predict Step Gaussian Contours',
                    xaxis: { 
                        title: 'Position',
                        range: [-3, 3]
                    },
                    yaxis: { 
                        title: 'Velocity',
                        range: [-2, 2]
                    },
                    legend: {
                        orientation: 'h',
                        yanchor: 'top',
                        xanchor: 'center',
                        y: 1.1,
                        x: 0.5,
                    },
                    hovermode: 'closest',
                };
    
                let traces_old = generateGaussianEllipticalContours(means[0], sigmas[0], color='blue', name='Current State');
                let traces_new = generateGaussianEllipticalContours(means[1], sigmas[1], color='red', name='Next State');
                let traces = traces_old.concat(traces_new);
                Plotly.react('predict-step-plot', traces, layout);
            }
    
            // Draggable+plotted: current state and covariance
            const x0 = document.getElementById("predict-step-x-mean-0");
            const x1 = document.getElementById("predict-step-x-mean-1");
            const P00 = document.getElementById("predict-step-P-sigma-00");
            const P01 = document.getElementById("predict-step-P-sigma-01");
            const P11 = document.getElementById("predict-step-P-sigma-11");
    
            // Draggable+not-plotted: state transition matrix, process noise, and control input
            const F00 = document.getElementById("predict-step-F-00");
            const F01 = document.getElementById("predict-step-F-01");
            const F10 = document.getElementById("predict-step-F-10");
            const F11 = document.getElementById("predict-step-F-11");
            const Q00 = document.getElementById("predict-step-Q-00");
            const Q01 = document.getElementById("predict-step-Q-01");
            const Q11 = document.getElementById("predict-step-Q-11");
            const u0 = document.getElementById("predict-step-u-0");
    
            // Constant: control matrix 
            const B00 = document.getElementById("predict-step-B-00");
            const B10 = document.getElementById("predict-step-B-10");
    
            // Dynamic (not Draggable) + not-plotted: state transition matrix mirrors and Q[1][0]
            const F00_mirror1 = document.getElementById("predict-step-F-00-mirror1");
            const F01_mirror1 = document.getElementById("predict-step-F-01-mirror1");
            const F10_mirror1 = document.getElementById("predict-step-F-10-mirror1");
            const F11_mirror1 = document.getElementById("predict-step-F-11-mirror1");
            const F00_mirror2 = document.getElementById("predict-step-F-00-mirror2");
            const F01_mirror2 = document.getElementById("predict-step-F-01-mirror2");
            const F10_mirror2 = document.getElementById("predict-step-F-10-mirror2");
            const F11_mirror2 = document.getElementById("predict-step-F-11-mirror2");
            const Q10 = document.getElementById("predict-step-Q-10");
    
            // Dynamic (not Draggable) + plotted: New state and covariance, and P[1][0]
            const newx0 = document.getElementById("predict-step-new-x-mean-0");
            const newx1 = document.getElementById("predict-step-new-x-mean-1");
            const newP00 = document.getElementById("predict-step-new-P-sigma-00");
            const newP01 = document.getElementById("predict-step-new-P-sigma-01");
            const newP10 = document.getElementById("predict-step-new-P-sigma-10");
            const newP11 = document.getElementById("predict-step-new-P-sigma-11");
            const P10 = document.getElementById("predict-step-P-sigma-10");
    
            // Restrict P and Q to be positive semi-definite and symmetric
            P00.setValidityCondition((newValue) => {
                return isPositiveSemiDefinite([[newValue, P01.value], [P01.value, P11.value]])
            });
            P01.setValidityCondition((newValue) => {
                return isPositiveSemiDefinite([[P00.value, newValue], [newValue, P11.value]])
            });
            P11.setValidityCondition((newValue) => {
                return isPositiveSemiDefinite([[P00.value, P01.value], [P01.value, newValue]])
            });
    
            Q00.setValidityCondition((newValue) => {
                return isPositiveSemiDefinite([[newValue, Q01.value], [Q01.value, Q11.value]])
            });
            Q01.setValidityCondition((newValue) => {
                return isPositiveSemiDefinite([[Q00.value, newValue], [newValue, Q11.value]])
            });
            Q11.setValidityCondition((newValue) => {
                return isPositiveSemiDefinite([[Q00.value, Q01.value], [Q01.value, newValue]])
            });
    
            function updatePredictStepDiagram() {
                // Note: P10=P01 since the matrix is symmetric,
                const old_state_mean = [[x0.value], [x1.value]];
                const old_state_cov = [
                    [P00.value, P01.value],
                    [P01.value, P11.value]
                ];
    
                const F = [
                    [F00.value, F01.value],
                    [F10.value, F11.value]
                ];
                const F_transpose = [
                    [F00.value, F10.value],
                    [F01.value, F11.value]
                ];
    
                let new_state_mean = matMul(F, old_state_mean);
                new_state_mean[0][0] += parseFloat(B00.textContent) * u0.value;
                new_state_mean[1][0] += parseFloat(B10.textContent) * u0.value;
    
                let new_state_cov = matMul(matMul(F, old_state_cov), F_transpose);
                new_state_cov[0][0] += Q00.value;
                new_state_cov[0][1] += Q01.value;
                new_state_cov[1][0] += Q01.value;
                new_state_cov[1][1] += Q11.value;
    
                // Update all the new x,P
                newx0.textContent = new_state_mean[0][0].toFixed(2);
                newx1.textContent = new_state_mean[1][0].toFixed(2);
                newP00.textContent = new_state_cov[0][0].toFixed(2);
                newP01.textContent = new_state_cov[0][1].toFixed(2);
                newP10.textContent = new_state_cov[1][0].toFixed(2);
                newP11.textContent = new_state_cov[1][1].toFixed(2);
                
    
                // Update the State Transition Matrix mirrors
                F00_mirror1.textContent = F00.value.toFixed(2);
                F01_mirror1.textContent = F01.value.toFixed(2);
                F10_mirror1.textContent = F10.value.toFixed(2);
                F11_mirror1.textContent = F11.value.toFixed(2);
                F00_mirror2.textContent = F00.value.toFixed(2);
                F01_mirror2.textContent = F10.value.toFixed(2); // second mirror is a transpose
                F10_mirror2.textContent = F01.value.toFixed(2); // second mirror is a transpose
                F11_mirror2.textContent = F11.value.toFixed(2);
    
                // symmetric covariances
                P10.textContent = P01.value.toFixed(2);
                Q10.textContent = Q01.value.toFixed(2);
    
                updatePredictStepPlot([old_state_mean, new_state_mean], [old_state_cov, new_state_cov]);
            }
    
            // For each draggable, add a callback to update everything else
            [F00, F01, F10, F11, x0, x1, P00, P01, P11, Q00, Q01, Q11, u0].forEach(element => {
                element.addEventListener('change', updatePredictStepDiagram);
            });
    
            // Initial plot
            updatePredictStepDiagram();
        })();
        </script>
    </div>
    
    <h3> Let's try running this Predict-Only Filter in state space!</h3>
    <div>
        <div id="predict-only-filter-diagram">    
            <div class="animation-container">
                <!-- SVG Robot -->
                <svg
                    width="78.827438mm"
                    height="90.709648mm"
                    viewBox="0 0 78.827438 90.709648"
                    version="1.1"
                    class="animation-robot"
                    xml:space="preserve"
                    xmlns="http://www.w3.org/2000/svg"
                    xmlns:svg="http://www.w3.org/2000/svg"><defs
                    class="defs1" /><g
                    class="body-layer"
                    transform="translate(-22.948456,-89.841802)"><path
                        style="opacity:0.99;fill:#a9c2ff;stroke:#858585;stroke-width:0.315"
                        d="m 60,90 c 9.621514,-0.06872 27.937315,4.966259 35,20 4.885644,8.69531 7.13726,41.14576 3.852748,47.30871 -3.130752,5.87445 -32.595817,6.76909 -39.141815,6.62609 -5.654366,-0.0512 -28.523962,0.63944 -31.397083,-7.34956 -3.240816,-11.23592 6.026113,-21.40713 7.734165,-41.25892 C 36.681208,107.96705 32.12253,92.455092 60,90 Z"
                        class="body-blob" /><circle
                        style="opacity:0.99;fill:#dcdffc;fill-opacity:1;stroke:#858585;stroke-width:0.315"
                        class="eye-white"
                        cx="77.621758"
                        cy="111.97367"
                        r="9.547823" /><circle
                        style="opacity:1;fill:#0f113f;fill-opacity:1;stroke:#020202;stroke-width:0.495001;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                        class="eye-pupil"
                        cx="77.621758"
                        cy="111.97367"
                        r="2.6847837" /><g
                        class="ultrasonic-group"
                        transform="matrix(0.46871921,0,0,0.46871921,-27.37283,72.641369)"><path
                        class="rect6"
                        style="opacity:1;fill:#0f113f;fill-opacity:1;stroke:#858585;stroke-width:0.495001;stroke-linecap:square"
                        d="m 127.17951,61.399733 12.57342,10.103943 -0.0408,63.504364 -12.50358,-10.33231 z" /><g
                        class="ultrasonic-cylinder-1"><path
                            class="rect5"
                            style="opacity:1;fill:#bcc2cf;fill-opacity:1;stroke:#858585;stroke-width:0.495;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none"
                            d="m 121.33471,71.751176 c -0.48654,0 -0.8785,0.391438 -0.8785,0.877983 v 20.853507 c 0,0.486545 0.39196,0.877983 0.8785,0.877983 h 11.71867 v 0 c 2.05411,-6.42e-4 4.84521,-5.137415 4.84518,-11.304737 3e-5,-6.167322 -2.79107,-11.304094 -4.84518,-11.304736 v 0 z" /><ellipse
                            style="opacity:0.99;fill:#25282e;fill-opacity:1;stroke:#858585;stroke-width:0.769677"
                            class="path3"
                            cx="120.45645"
                            cy="83.1931"
                            rx="3.719537"
                            ry="11.167632" /></g><g
                        class="ultrasonic-cylinder-2"><path
                            class="path7"
                            style="opacity:1;fill:#bcc2cf;fill-opacity:1;stroke:#858585;stroke-width:0.495;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none"
                            d="m 121.33471,100.66893 c -0.48654,0 -0.8785,0.39144 -0.8785,0.87799 v 20.8535 c 0,0.48655 0.39196,0.87799 0.8785,0.87799 h 11.71867 v 0 c 2.05411,-6.4e-4 4.84521,-5.13742 4.84518,-11.30474 3e-5,-6.16732 -2.79107,-11.30409 -4.84518,-11.30474 v 0 z" /><ellipse
                            style="opacity:0.99;fill:#25282e;fill-opacity:1;stroke:#858585;stroke-width:0.769677"
                            class="ellipse7"
                            cx="120.45645"
                            cy="112.11086"
                            rx="3.719537"
                            ry="11.167632" /></g></g></g><g
                    class="wheel-layer"
                    transform="translate(-22.948456,-89.841802)"><g
                        class="front-wheel"
                        style="display:inline"
                        transform="translate(-49.063398,7.483203)"><circle
                        style="opacity:1;fill:#121212;fill-opacity:1;stroke:#020202;stroke-width:0.495001;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                        class="axle1"
                        cx="134.39388"
                        cy="156.62283"
                        r="1.7787484" /><circle
                        style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:4;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                        class="front-tire"
                        cx="134.39388"
                        cy="156.62283"
                        r="14.445418" /><circle
                        style="fill:none;fill-opacity:1;stroke:#020202;stroke-width:2.17772;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                        class="path9-9"
                        cx="134.39388"
                        cy="156.62283"
                        r="9.6793108" /><circle
                        style="fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                        class="circle9"
                        cx="134.39388"
                        cy="156.62283"
                        r="3.6967146" /><g
                        class="front-spokes-1"><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 134.39387,152.92612 v -5.9826"
                            class="path10" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 138.09059,156.62283 h 5.98259 v 0"
                            class="path11" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 134.39387,160.31955 v 5.98259"
                            class="path12" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 130.69716,156.62283 h -5.9826"
                            class="path13" /></g><g
                        class="front-spokes-2"
                        transform="rotate(45,134.39387,156.62284)"><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 134.39387,152.92612 v -5.9826"
                            class="path17" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 138.09059,156.62283 h 5.98259 v 0"
                            class="path18" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 134.39387,160.31955 v 5.98259"
                            class="path19" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 130.69716,156.62283 h -5.9826"
                            class="path20" /></g></g><g
                        class="rear-wheel"
                        style="display:inline"
                        transform="translate(-95,7.483203)"><circle
                        style="opacity:1;fill:#121212;fill-opacity:1;stroke:#020202;stroke-width:0.495001;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                        class="axle2"
                        cx="134.39388"
                        cy="156.62283"
                        r="1.7787484" /><circle
                        style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:4;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                        class="circle36"
                        cx="134.39388"
                        cy="156.62283"
                        r="14.445418" /><circle
                        style="fill:none;fill-opacity:1;stroke:#020202;stroke-width:2.17772;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                        class="circle37"
                        cx="134.39388"
                        cy="156.62283"
                        r="9.6793108" /><circle
                        style="fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                        class="circle38"
                        cx="134.39388"
                        cy="156.62283"
                        r="3.6967146" /><g
                        class="g41"><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 134.39387,152.92612 v -5.9826"
                            class="path38" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 138.09059,156.62283 h 5.98259 v 0"
                            class="path39" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 134.39387,160.31955 v 5.98259"
                            class="path40" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 130.69716,156.62283 h -5.9826"
                            class="path41" /></g><g
                        class="g45"
                        transform="rotate(45,134.39387,156.62284)"><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 134.39387,152.92612 v -5.9826"
                            class="path42" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 138.09059,156.62283 h 5.98259 v 0"
                            class="path43" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 134.39387,160.31955 v 5.98259"
                            class="path44" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 130.69716,156.62283 h -5.9826"
                            class="path45" /></g></g></g>
                    </svg>
            </div>
            <div id="predict-only-filter-plot"></div>
            <table class="math-diagram-structure-table">
                <tr>
                    <td>Control the robot's acceleration by dragging the number: \( \controlInput = \)</td>
                    <td>
                        <table class="matrix-table">
                            <tr>
                                <td>
                                    <draggable-number class="control-input-slider" min="-1" max="1" value="0.0" step="0.1"></draggable-number>
                                </td>
                            </tr>
                        </table>
                    </td>
                </tr>
                <tr>
                    <td>
                        <button class="start-button">Start</button>
                        <button class="stop-button">Stop</button>
                        <button class="reset-button">Reset</button>
                    </td>
                </tr>
            </table>
        </div>
            <script>
                (function() {
                const diagram = document.getElementById('predict-only-filter-diagram');
                // Also need to change the Plotly id
                const robot = diagram.querySelector('.animation-robot');
                const slider = diagram.querySelector('.control-input-slider');
                const container = diagram.querySelector('.animation-container');
                const startButton = diagram.querySelector('.start-button');
                const stopButton = diagram.querySelector('.stop-button');
                const resetButton = diagram.querySelector('.reset-button');
    
                /////////////////////////////////////////////////////////////
                // Kalman Filter parameters + models
                const wheelRadius = 50; //px (didn't actually measure this)
                const maxVelocity = 400; //px/sec
                const maxAngularAcceleration = 5; //rad/sec^2
                const KF_dt_min = 0.2; //seconds (determines how often the Predict step runs)
                const meas_dt_min = 0.5; //seconds (determines how often the Update step runs)
    
                // Truestate variables
                let throttle;  // -1 to 1
                let x; //px/s
    
                // Estimated state variables
                let x_est;
                let P_est;
    
                function resetAllVariables() {
                    // Truestate variables
                    throttle = parseFloat(slider.value);  // -1 to 1
                    x = [[0], //px
                        [100]]; //px/s
    
                    // Estimated state variables
                    const initial_state_variance = 100;
                    x_est = x;
                    P_est = [[initial_state_variance,0],[0,initial_state_variance]];
                }
                resetAllVariables();
    
                /////////////////////////////////////////////////////////////
                /////////////////////////////////////////////////////////////
    
                // Pupil animation
                const frontWheel = robot.querySelector('.front-wheel');
                const rearWheel = robot.querySelector('.rear-wheel');
                const pupil = robot.querySelector('.eye-pupil');
                const eyeWhite = robot.querySelector('.eye-white');
    
                function updatePupilPosition(mouseX, mouseY) {
                    const eyeWhiteRect = eyeWhite.getBoundingClientRect();
                    const pupilRect = pupil.getBoundingClientRect();
                    // Calculate the center of the eye
                    const eyeCenterX = eyeWhiteRect.left + eyeWhiteRect.width / 2;
                    const eyeCenterY = eyeWhiteRect.top + eyeWhiteRect.height / 2;
        
                    // Calculate the angle between the eye center and the mouse position
                    const angle = Math.atan2(mouseY - eyeCenterY, mouseX - eyeCenterX);
                    const distance = Math.sqrt((mouseX - eyeCenterX) * (mouseX - eyeCenterX) + (mouseY - eyeCenterY) * (mouseY - eyeCenterY));
        
                    // Calculate the maximum distance the pupil can move from the center
                    const maxDistance = (eyeWhiteRect.width - pupilRect.width) / 2;
        
                    // Calculate the new position of the pupil
                    let pupilX = Math.cos(angle) * Math.min(distance, maxDistance);
                    let pupilY = Math.sin(angle) * Math.min(distance, maxDistance);
                    
                    // Apply the new position to the pupil
                    pupil.style.transform = `translate(${pupilX}px, ${pupilY}px)`;
                }
        
                // Add event listener for mouse movement
                container.addEventListener('mousemove', (e) => {
                    updatePupilPosition(e.clientX, e.clientY);
                });
    
                // Update velocity when the slider value changes
                slider.addEventListener('input', () => {
                    throttle = parseFloat(slider.value);
                });
    
                // State-space plot
                function updateStatePlot(x, x_est, P_est) {
                    // Inputs:
                    // x: true state (2x1 array)
                    // x_est: estimated state (2x1 array)
                    // P_est: estimated covariance (2x2 array)
                    // Check input shapes
                    if (!Array.isArray(x) || x.length !== 2 || !Array.isArray(x[0]) || x[0].length !== 1 ||
                        !Array.isArray(x_est) || x_est.length !== 2 || !Array.isArray(x_est[0]) || x_est[0].length !== 1 ||
                        !Array.isArray(P_est) || P_est.length !== 2 || !Array.isArray(P_est[0]) || P_est[0].length !== 2) {
                        console.error(`Invalid input shapes for updateStatePlot: x: ${x}, x_est: ${x_est}, P_est: ${P_est}`);
                        return;
                    }
                    //get the max width of the container for the state-diagram plot
                    const maxY = maxVelocity+100;
                    const lMargin = 40;
                    const rMargin = 40;
                    const layout = {
                        title: 'Predict-Only Filter State Space',
                        legend: {
                            orientation: 'h',
                            yanchor: 'top',
                            xanchor: 'center',
                            y: 1.05,
                            x: 0.5,
                        },
                        yaxis: {
                            title: 'Velocity (Pixels/Second)',
                            range: [-maxY,maxY],
                        },
                        xaxis: {
                            title: 'Position (Pixels)',
                            range: [0,container.clientWidth-lMargin-rMargin], // axis labels take some space
                        },
                        margin: {
                        l: lMargin,
                        r: rMargin,
                        t: 50,
                        b: 40,
                        },
                        hovermode: 'closest',
                    }
                    function getPlotPosition(x) {
                        return positiveModulo(x[0][0], container.clientWidth + 2*robot.clientWidth) - robot.clientWidth/2; //robot.clientWidth/2 is an offset so dot is at front or robot
                    }
                    // Apply the new position and wheel rotation to the robot
                    const pixel_position = getPlotPosition(x);
    
                    const center_true = {
                        x: [pixel_position],
                        y: [x[1][0]],
                        type: 'scatter',
                        mode: 'markers',
                        marker: { color: 'black' },
                        showlegend: true,
                        name: 'True State'
                    }
                    const x_est_mod = [[getPlotPosition(x_est)],
                                        [x_est[1][0]]];
                    if (x_est_mod[1][0] > maxY+ 50) {
                        // just draw an arrow indicating where it is
                        const center_est_arrow = {
                            x: [x_est_mod[0][0]],
                            y: [maxY-30],
                            type: 'scatter',
                            mode: 'markers',
                            marker: {
                                symbol: 'triangle-up',
                                size: 12,
                                color: 'red'
                            },
                            showlegend: true,
                            name: 'Estimated State',
                        }
                        const traces = [center_true, center_est_arrow];
                        Plotly.react('predict-only-filter-plot', traces, layout);
                    }
                    else if (x_est_mod[1][0] < -maxY-50) {
                        const center_est_arrow = {
                            x: [x_est_mod[0][0]],
                            y: [-maxY+30],
                            type: 'scatter',
                            mode: 'markers',
                            marker: {
                                symbol: 'triangle-down',
                                size: 12,
                                color: 'red'
                            },
                            showlegend: true,
                            name: 'Estimated State',
                        }
                        const traces = [center_true, center_est_arrow];
                        Plotly.react('predict-only-filter-plot', traces, layout);
                    }
                    else {
                        const center_est = {
                            x: [x_est_mod[0][0]],
                            y: [x_est_mod[1][0]],
                            type: 'scatter',
                            mode: 'markers',
                            marker: { color: 'red' },
                            showlegend: false,
                        }
                        const contours_est = generateGaussianEllipticalContours(x_est_mod, P_est, color='red', name='Estimated State');
                        const traces = [center_true, center_est].concat(contours_est);
                        Plotly.react('predict-only-filter-plot', traces, layout);
                    }
                }
                
                
                ///// Animation Start/Stop Controls /////
                // Stop running the animation when the user can't see it
                let animationRunning = true;
                function startAnimation() {
                    animationRunning = true;
                    requestAnimationFrame(animateRobot);
                }
                function stopAnimation() {
                    animationRunning = false;
                }
                function resetAnimation() {
                    resetAllVariables();
                    renderAnimationAndPlot(x, x_est, P_est);
                }
                // Stop running when the user can't see the animation
                function handleIntersection(entries) {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            startAnimation();
                        } else {
                            stopAnimation();
                        }
                    });
                }
                const observer = new IntersectionObserver(handleIntersection, {
                    root: null, // Use the viewport as the root
                    threshold: 0.1 // Trigger when 10% of the element is visible
                });
                observer.observe(container);
    
                // Start/Stop/Reset buttons
                startButton.addEventListener('click', () => {
                    startAnimation();
                });
                stopButton.addEventListener('click', () => {
                    stopAnimation();
                });
                resetButton.addEventListener('click', () => {
                    resetAnimation();
                });
    
                // Function to animate the robot
                function renderAnimationAndPlot(x, x_est, P_est) {
                    const wheelRotation = positiveModulo(x[0][0]/wheelRadius * 180/Math.PI, 360);
        
                    // Apply the new position and wheel rotation to the robot
                    const pixel_position = positiveModulo(x[0][0], container.clientWidth + 2*robot.clientWidth) - robot.clientWidth;
                    robot.style.left = `${pixel_position}px`;
                    // In the SVG the front wheel was originally drawn centered at 134.39388px 156.62283px
                    // then the whole front wheel was translated by -47.066795px, 7.9443462px
                    // We need to rotate the wheel about its translated center
                    frontWheel.style.transformOrigin = `${134.39388 - 47.066795}px ${156.62283 + 7.9443462}px`;
                    frontWheel.style.transform = `rotate(${wheelRotation}deg) translate(-47.066795px, 7.9443462px)`;
        
                    // In the SVG the rear wheel was originally drawn centered at 134.39388px 156.62283px
                    // then the whole rear wheel was translated by -95px, 7.9443462px
                    // We need to rotate the wheel about its translated center
                    rearWheel.style.transformOrigin = `${134.39388 - 95}px ${156.62283 + 7.9443462}px`;
                    rearWheel.style.transform = `rotate(${wheelRotation}deg) translate(-95px, 7.9443462px)`;
    
                    updateStatePlot(x, x_est, P_est);
                }
    
                let t_prev;
                let KF_t_prev; // Kalman Filter runs at slower rate than true state
                let measurement_t_prev; // Measurement update runs at slower rate than Kalman Filter
    
                function animateRobot(timestamp) {
                    if (!animationRunning) {
                        t_prev = undefined;
                        return;
                    }
                    if (timestamp === undefined) {
                        console.error('animateRobot: timestamp is undefined. Ensure that animateRobot is being called by requestAnimationFrame or otherwise being passed a timestamp.');
                    }
                    if (t_prev === undefined) {
                        t_prev = timestamp;
                        KF_t_prev = timestamp;
                        measurement_t_prev = timestamp;
                    }
                    // True state
                    const dt = (timestamp - t_prev) / 1000;
                    t_prev = timestamp;
                    x = trueStateModel(x, dt, throttle, wheelRadius, maxVelocity, maxAngularAcceleration);
    
                    // Kalman state
                    const KF_dt = (timestamp - KF_t_prev) / 1000; // ms to seconds
                    const meas_dt = (timestamp - measurement_t_prev) / 1000;
                    if (KF_dt >= KF_dt_min) {
                        KF_t_prev = timestamp;
                        [x_est, P_est] = propagateKalmanFilter(x_est, P_est, KF_dt, throttle, wheelRadius, maxAngularAcceleration);
                        // if (meas_dt >= meas_dt_min) {
                        //     measurement_t_prev = timestamp;
                        //     // Take a measurement if possible
                        //     const z = trueMeasurementModel(x);
                        //     [x_est, P_est] = propagateKalmanFilter(x_est, P_est, KF_dt, throttle, wheelRadius, maxAngularAcceleration, z);
                        // } 
                    }
    
                    renderAnimationAndPlot(x, x_est, P_est);
                    requestAnimationFrame(animateRobot);
                }
        
                // Start the animation
                updatePupilPosition(450,170);
                requestAnimationFrame(animateRobot);
    
                })();
            </script>
    </div>
    
    <h2>Sensing the environment</h2>
    <img class="expanded-content" src="./assets/ultrasonic-sensor-HC-SR04-mouser.png" alt="Picture of an ultrasonic distance sensor" id="ultrasonic-sensor-picture">
    <p>Ok so the state ... isn't terrible, but it's not great either, and the variance is exploding (which is reasonable considering the 
        dynamics equation has no feedback).
        Fortunately, we have endowed this robot with an 
        <span class="expandable-content-text" onclick="toggleExpandableContent('ultrasonic-sensor-picture')">ultrasonic distance sensor</span>
        that should help.
        This sensor will output a measurement vector containing one value corresponding to the distance to the nearest object.
        $$ \text{Measurement Vector } \measurement = \begin{bmatrix} \text{distance} \end{bmatrix} $$
        The only question is, how do we incorporate these measurements into the filter? 
    </p>
    <p>
        To start with, we need a linear model that relates the measurement vector \( \measurement \) to the state.
        Our first instinct might be to write a matrix that converts from the measurement vector to the state vector 
        (we're trying to update the state after all). The problem is 
        that since the sensor doesn't measure the velocity, there is no way to fully recover the state from the measurement 
        using a linear transformation. We can however think about this from a more causal perspective: 
    </p>
    <p>
        In reality we know that the robot is in some true state \( \trueState \), and when the sensor takes a measurement
        of that state it will generally follow a linear process. If we define the measurement matrix \(\measurementMatrix\)
        to describe this linear measurement process, then in the ideal case we can write:
        $$ \measurement_{\text{ideal}} = \measurementMatrix \trueState $$
    </p>
    <p>Let's get into some 
        <span class="expandable-content-text" onclick="toggleExpandableContent('ultrasonic-implementation-details')">implementation details</span>
        to see what \(\measurementMatrix\) looks like. 
    </p>
    <div class="expanded-content" id="ultrasonic-implementation-details">
        <a href="https://youtu.be/KGwtit2bFyo?feature=shared&t=14" target="_blank" rel="noopener noreferrer">
            This video does a great job of explaining how ultrasonic sensors work
        </a>
    </div>
    <!-- <iframe  
        class="expanded-content" 
        id="ultrasonic-implementation-details"
        width="560" 
        height="315" 
        src="https://www.youtube.com/embed/KGwtit2bFyo?si=cWVWC1Fgix_Gl9C_&amp;start=14" 
        title="YouTube video player" 
        frameborder="0" 
        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" 
        referrerpolicy="strict-origin-when-cross-origin" 
        allowfullscreen>
    </iframe> -->
    <p>
        Most ultrasonic sensors do not directly provide a distance. Instead, they measure 
        the time (in microseconds, \( \mu s \)) it takes for a pulse of sound to travel to the wall and back. In order to convert from \( \mu s \)
        to meters, we need to multiply by a factor of \( \frac{2 \times 10^6 }{c} \), where \(c\) is the speed of sound in air (343 \( m/s \)), 
        there are \( 10^6 \mu s \) per second, and the factor of 2 accounts for the sound traveling double the distance (to the wall, and then back).
        Thus to convert from the measurement vector to the state vector, the measurement matrix would be:
        $$ \text{Measurement Matrix } \measurementMatrix = \begin{bmatrix} \frac{2 \times 10^6 }{c} & 0 \end{bmatrix} $$
    </p>
    <p>Of course, no sensor is ever perfect, so we will also say that when the sensor takes a measurement 
        it will also introduce some sensor noise. We assume that the noise is normally distributed with 
        zero mean and covariance \(\measurementNoiseCovariance\) (which hopefully is listed in the sensor datasheet).
        $$ \text{Measurement Noise} \sim \gaussian \left( 0, \measurementNoiseCovariance \right) $$
        
        Now we can say that when the robot is in state \( \trueState \), the measurements you can expect to get will
        follow a normal distribution with covariance \(\measurementNoiseCovariance\) and mean \(\measurementMatrix \trueState\).
        Of course, we never actually see the entirety of this distribution; the robot will only ever take 
        individual measurements. Since \( \measurement \) is the only sample we have, 
        we will say that every time we read some measurement, we infer that the distribution of possible 
        measurements is a gaussian centered at \( \measurement \) with covariance \(\measurementNoiseCovariance\):
        $$ \text{Possible Measurements}\sim \gaussian \left( \measurement, \measurementNoiseCovariance \right) $$
    </p>

    <p> To summarize, we've defined the measurement matrix \( \measurementMatrix \), whose role is to 
        convert from the space of states to the space of measurements. 
        We've used it here to convert from the ideal state to an ideal measurement, but in the 
        next section we will see that \( \measurementMatrix \) can also be applied 
        to the entire distribution of our current state estimate. This operation yields the measurement 
        we expect given the current state estimate. 
    </p>
    
    <h2>Update Step: Combining two gaussians</h2>
    <p>
        At this point, we have one normal distribution that represents our belief of the true state of the robot,
        and another normal distribution that represents the measurements you'd expect to get from the true state. 
        How can we combine these two distributions into one new state estimate? 
        $$ \text{State Estimate distribution from the Prediction Step: }\gaussian \left( \state, \stateCovariance \right) $$
        $$ \text{Measurement distribution inferred from the actual measurement: } \gaussian \left( \measurement, \measurementNoiseCovariance \right) $$
    </p>
    <p>The first challenge we face is that we're trying to combine different "types" of things.
        The state estimate distribution has a mean and variance with a particular dimension and units,
        while the measurement distribution has entirely different dimensions and units. Before
        we can do any combining, we have to first get both distributions into the same space. 
    </p>
    <p>There are two ways to do approach this. Choose your own adventure!
    </p>
    <table style="width: 100%;">
        <tr>
            <td>
                <button id='option1-button' onclick="activateButtonsAndContent(['option1-button'], ['update-step-option1'], ['option2-button'], ['update-step-option2'])">
                    Option 1
                </button>
            </td>
            <td>
                <button id='option2-button' onclick="activateButtonsAndContent(['option2-button'], ['update-step-option2'], ['option1-button'], ['update-step-option1'])">
                    Option 2
                </button>
            </td>
        </tr>
    </table>
    <div id="update-step-option1" class="expanded-content-long">
        <p>
            The first way we could approach combining the measurement distribution 
            with the state estimate distribution can be outlined as follows:
            <ol>
                <li>See what measurement we should expect given our current state estimate</li>
                <li>Combine this with the actual measurement we got</li>
                <li>Convert a "fused measurement" back to state space</li>
            </ol>
            Let's break this down.
        </p> 

        <p>In order to put our two distributions on the same footing, we'll multiply the
            state estimate distribution by \( \measurementMatrix \) to bring it into 
            to the space of measurements. 
            Remembering our 
            <span class="expandable-content-text" onclick="toggleExpandableContent('duplicate-gaussian-multiplication-rule')">
                rule for multiplying gaussians</span>, we'll get two normal distributions in the same space:
            <div class="expanded-content" id="duplicate-gaussian-multiplication-rule"></div>
        
            <ul>
                <li>The measurement distribution you'd expect given your Predicted State: \( \gaussian \left( \measurementMatrix \state, \space \measurementMatrix \stateCovariance \measurementMatrix^T \right) \)</li>
                <li>The measurement distribution inferred from the actual measurement: \( \gaussian \left( \measurement, \space \measurementNoiseCovariance \right) \)</li>
            </ul>
        </p>
    
        <div id="what-we-want-of-gaussians">
            <p>Now that we have two distributions in the same space, we can stop to think: what would we like to 
                be true when we combine these estimates? Here are some things that would be nice:
            </p>
            <ol>
                <li>The mean of the combined estimate should always lie between the means of the two original estimates</li>
                <li>The uncertainty (ie. variance) should be smaller than the uncertainty of either of the original estimates</li>
                <li>The resulting estimate should more closely resemble the distribution in which we have higher confidence (ie. less variance).</li>
            </ol>
            
            <p>For example, if we know that the ultrasonic sensor is much more accurate than our dynamics model (which is propagated blindly), then 
                we'd want our combined estimate to consist mostly of the sensor measurement, with a hint of the dynamics model 
                to account for small measurement noise. Since we're making use of all of our information, we should 
                be more certain of our combined estimate than either of the original estimates independently.
            </p>
        </div>
        <p>But how much, exactly, of each estimate do we want to use? One reasonable approach is to weight each distribution 
            by the inverse of its variance, so the distribution with less uncertainty (ie. smaller variance) will play more of a role.
            To write this mathematically, we first define the variance ratio (in the space of measurements):
            $$ \varianceRatio = 
            \frac{\measurementMatrix \stateCovariance \measurementMatrix^T}{\measurementMatrix \stateCovariance \measurementMatrix^T + \measurementNoiseCovariance} =
            \frac{\text{Uncertainty from state estimate}}{\text{Total uncertainty from the state estimate and sensor noise}} $$
        </p>
        <p class="expandable-content-text" onclick="toggleExpandableContent('matrix-fractions-explanation')">
            Wait, you can write a matrix inverse like a fraction?!
        </p>
        <p class="expanded-content" id="matrix-fractions-explanation">
            Technically, writing a matrix fraction is not legitimate because matrices (unlike scalars) 
            very much care whether the numerator is multiplied on the left or right of the denominator, 
            but the fraction form does not contain this information. That being said, the insight that 
            this is a simple ratio is hieghtened by the fractional notation, so I ask that you simply 
            remember that the inverse goes on the right. 
        </p>
        
        <p class="expandable-content-text" onclick="toggleExpandableContent('bayes-rule-explanation')">
            Is there a deeper mathematical reason why we use the variance ratio?
        </p>
        <p class="expanded-content" id="bayes-rule-explanation"> 
            Yes! You may have learned about Bayes' Rule, which describes how to update your beliefs 
            in light of new information. In particular, it says that 
    
            $$ P( A | B ) = \frac{P( B | A ) P( A )}{P( B )}$$
            $$ \text{Posterior} = \frac{\text{Likelihood} \times \text{Prior}}{\text{Normalizing constant}} $$
    
            In our case, the prior is the state estimate from the prediction step, 
            the likelihood comes from our measurement, and the posterior is our combined estimate.
            $$ P(\state | \measurement) = \frac{P(\measurement | \state) P(\state)}{P(\measurement)} $$
    
            The primary peculiarity of the Kalman Filter is that instead of having individual numbers 
            for each probability in the equation, now we have gaussian distributions. Nonetheless, the 
            principle of multiplying the likelihood by the prior and normalizing is the same. If you 
            multiply two gaussian probability density functions, you can actually show that
            the variance ratio emerges! For example, in 1D you could algebraically show :
    
            $$ C_1 \exp \left( -\frac{(x-\mu_1)^2}{2\sigma_1^2} \right) \times 
                C_2 \exp \left( -\frac{(x-\mu_2)^2}{2\sigma_2^2} \right) = 
                C_3 \exp \left( -\frac{(x-\mu_3)^2}{2\sigma_3^2} \right) $$
    
            Where the \( C \) terms are normalization constants, and the mean and variance of the resulting distribution are:
            $$ \mu_3 = \left( 1 - \frac{\sigma_1^2}{\sigma_1^2 + \sigma_2^2} \right) \mu_1 + 
                                    \frac{\sigma_1^2}{\sigma_1^2 + \sigma_2^2} \mu_2 $$
            $$ \sigma_3^2 = \sigma_1^2 - \frac{\sigma_1^2}{\sigma_1^2 + \sigma_2^2} \sigma_1^2 $$
        </p>
    
        <p>Then we can use this to write a weighted sum of each distribution:
            $$ \state_{\discreteTime} = \measurementMatrix^{-1} \left[ \left( \identityMatrix - \varianceRatio \right) \measurementMatrix \state + \varianceRatio \measurement \right] $$
        </p>
    
        <p>
            Hold on, where did that \(\measurementMatrix^{-1}\) come from? Remember, at the end of the equation we need to get something that is in the space of states, 
            but we're currently in the space of measurements. Since \(\measurementMatrix\) converts from state space to measurement space, 
            we'd imagine that \(\measurementMatrix^{-1}\) goes the other way from measurements to states. 
        </p>
        <p> 
            There's only one problem: \(\measurementMatrix\) is not necessarily square, so it cannot be inverted. 
        </p>
    
        <p>
            Fortunately, there's a workaround! All we have to do is suspend our disbelief and pretend that 
            \(\identityMatrix = \measurementMatrix^{-1} \measurementMatrix\). Then we can distribute the \(\measurementMatrix^{-1}\) 
            into the formula and cancel it with existing \(\measurementMatrix\) terms, including the leading \(\measurementMatrix\) of 
            the variance ratio formula. The variance ratio without its leading \(\measurementMatrix\) is actually so important that 
            we'll give it a name:
            $$ \text{The Kalman Gain } \kalmanGain = \stateCovariance \measurementMatrix^T \left( \measurementMatrix \stateCovariance \measurementMatrix^T + \measurementNoiseCovariance \right)^{-1} $$
            Then we can write the variance ratio as:
            $$ \varianceRatio = \measurementMatrix \kalmanGain $$
            Now we can proceed in applying the distributive property to get our state update equation:
            $$ \begin{align*}
                \state_{\discreteTime} &= \measurementMatrix^{-1} \left[ (\identityMatrix - \varianceRatio) \measurementMatrix \state_{\discreteTime-1} + \varianceRatio \measurement \right] \\
                &= \left[ \left( \measurementMatrix^{-1} - \measurementMatrix^{-1} \varianceRatio \right) \measurementMatrix \state_{\discreteTime-1} + \measurementMatrix^{-1} \varianceRatio \measurement \right] \\
                &= \left( \measurementMatrix^{-1} - \kalmanGain \right) \measurementMatrix \state_{\discreteTime-1} + \kalmanGain \measurement \\
                \state_{\discreteTime} &= \left( \identityMatrix - \kalmanGain \measurementMatrix \right) \state_{\discreteTime-1} + \kalmanGain \measurement \\
                \end{align*}
                $$
        </p>
    
        <p> Great! Now we have a matrix formula to combine the means of two Gaussians. The only step left is to propagate the variances too,
            which we can easily do using our <span class="expandable-content-text" onclick="toggleExpandableContent('duplicate-gaussian-multiplication-rule-4')">
                rule for multiplying Gaussians</span>. 
        </p>
        <div class="expanded-content" id="duplicate-gaussian-multiplication-rule-4"></div>
    
        <p>
            $$ \stateCovariance_{\discreteTime} = 
                \left( \identityMatrix - \kalmanGain \measurementMatrix \right) 
                \stateCovariance_{\discreteTime-1} 
                \left( \identityMatrix - \kalmanGain \measurementMatrix \right)^T 
                + \kalmanGain \measurementNoiseCovariance \kalmanGain^T 
            $$
        </p>
        <p>The equation above is known as the Joseph Form of the Covariance Update Equation.
            <span class="expandable-content-text" onclick="toggleExpandableContent('covariance-matrix-simplification')">
                There is also a simpler (though less numerically stable) form of this equation.
            </span>
        </p>

        <div class="expanded-content" id="covariance-matrix-simplification">
        $$ 
        \begin{align}
        \stateCovariance_{\discreteTime} &= \left( \identityMatrix - \kalmanGain \measurementMatrix \right) \stateCovariance_{\discreteTime-1} \class{highlight-term}{ \left(\identityMatrix - \kalmanGain \measurementMatrix \right)^T} + \kalmanGain \measurementNoiseCovariance \kalmanGain^T \\
         &= \left( \identityMatrix - \kalmanGain \measurementMatrix \right) \stateCovariance_{\discreteTime-1} \class{highlight-term}{ \left( \identityMatrix -  \left(\kalmanGain \measurementMatrix \right)^T \right) } + \kalmanGain \measurementNoiseCovariance \kalmanGain^T \\
         &= \left( \identityMatrix - \kalmanGain \measurementMatrix \right) \class{highlight-term}{ \stateCovariance_{\discreteTime-1} \left(\identityMatrix - \measurementMatrix^T \kalmanGain^T \right) } + \kalmanGain \measurementNoiseCovariance \kalmanGain^T \\
         &= \class{highlight-term}{ \left( \identityMatrix - \kalmanGain \measurementMatrix \right) \left(\stateCovariance_{\discreteTime-1} - \stateCovariance_{\discreteTime-1} \measurementMatrix^T \kalmanGain^T \right) } + \kalmanGain \measurementNoiseCovariance \kalmanGain^T \\
         &= \stateCovariance_{\discreteTime-1} - \kalmanGain \measurementMatrix \stateCovariance_{\discreteTime-1} - \stateCovariance_{\discreteTime-1} \measurementMatrix^T \kalmanGain^T + \class{highlight-term}{ \kalmanGain \measurementMatrix \stateCovariance_{\discreteTime-1} \measurementMatrix^T \kalmanGain^T + \kalmanGain \measurementNoiseCovariance \kalmanGain^T } \\
         &= \stateCovariance_{\discreteTime-1} - \kalmanGain \measurementMatrix \stateCovariance_{\discreteTime-1} - \stateCovariance_{\discreteTime-1} \measurementMatrix^T \kalmanGain^T + \class{highlight-term}{ \kalmanGain \left(\measurementMatrix \stateCovariance_{\discreteTime-1} \measurementMatrix^T + \measurementNoiseCovariance \right) } \kalmanGain^T \\
         &= \stateCovariance_{\discreteTime-1} - \kalmanGain \measurementMatrix \stateCovariance_{\discreteTime-1} \class{highlight-term}{ - \stateCovariance_{\discreteTime-1} \measurementMatrix^T \kalmanGain^T + \stateCovariance_{\discreteTime-1} \measurementMatrix^T \kalmanGain^T }\\
        \stateCovariance_{\discreteTime} &= \stateCovariance_{\discreteTime-1} - \kalmanGain \measurementMatrix \stateCovariance_{\discreteTime-1} 
        \end{align}
        $$
        This is a much simpler version of the covariance update equation! It clearly gives the insight that with new information, 
        your uncertainty will always decrease. The only limitation is that, without quadratic terms keeping things symmetric,
        small numerical errors can build up over time and lead to an invalid covariance matrix.
        </div>

        <p>
            Here's an interactive diagram to visualize the whole process. 
            The work done by the Kalman Gain is surrounded by a dashed box.
            Try sliding the underlined variables around to see how they affect the outcome!
        </p>
        <div id="measurement-kalman-gain-diagram">
            <table class="math-diagram-structure-table">
                <tr class="kalman-gain-state-space">
                    <th colspan="2" style="font-size: 1.3rem; padding: 10px;">Update Step (Measurement Space)</th>
                </tr>
                <tr class="kalman-gain-state-space">
                    <td>
                        <table class="math-diagram-structure-table">
                            <tr>
                                <td>\( \mathcal{N} \left( 
                                    \begin{eqnarray}
                                    \\
                                    \state_{\discreteTime - 1} \\
                                    \\
                                \end{eqnarray}
                                \right. =\)
                                <td>
                                    <table class="matrix-table">
                                        <tr>
                                            <td>
                                                <draggable-number id="kalman-gain-old-state-0" min="-4" max="4" step="0.01" value="1">1.0</draggable-number>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>
                                                <draggable-number id="kalman-gain-old-state-1" min="-4" max="4" step="0.01" value="1">1.0</draggable-number>
                                            </td>
                                        </tr>
                                    </table>
                                </td>
                                <td>, \( \stateCovariance_{\discreteTime-1} = \)</td>
                                <td>
                                    <table class="matrix-table">
                                        <tr>
                                            <td>
                                                <draggable-number id="kalman-gain-old-state-covariance-00" min="0" max="5" step="0.01" value="1">1.0</draggable-number>
                                            </td>
                                            <td>
                                                <draggable-number id="kalman-gain-old-state-covariance-01" min="-5" max="5" step="0.01" value="0.0">0.0</draggable-number>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>
                                                <div class="dynamic-number-container" id="kalman-gain-old-state-covariance-10">0.0</div>
                                            </td>
                                            <td>
                                                <draggable-number id="kalman-gain-old-state-covariance-11" min="0" max="5" step="0.01" value="1">1.0</draggable-number>
                                            </td>
                                        </tr>
                                    </table>
                                </td>
                                <td>\( \left. 
                                        \begin{eqnarray}
                                        \\
                                        \\
                                        \\
                                    \end{eqnarray}
                                    \right) \)
        
                            </tr>
                        </table>
                    </td>
                    <td></td>
                </tr>
                <tr class="kalman-gain-intermediate-space">
                    <td style="font-size: 24px;">&#x2193;</td> <!-- Down arrow -->
                    <td></td>
                </tr>
                <tr class="kalman-gain-intermediate-space">
                    <td>
                        Convert to Measurement Space with
                        \( \measurementMatrix = \begin{bmatrix} 1 & 0 \end{bmatrix} \)
                    </td>
                    <td></td>
                </tr>
                <tr class="kalman-gain-intermediate-space">
                    <td style="font-size: 24px;">&#x2193;</td> <!-- Down arrow -->
                    <td></td>
                </tr>
                <tr class="kalman-gain-measurement-space">
                    <td>
                        <table class="kalman-gain-state-gaussian-expr math-diagram-structure-table">
                            <td>
                                \(\mathcal{N} \left( \measurementMatrix \state_{\discreteTime-1} = 
                                \begin{eqnarray}
                                \\
                                \\
                                \end{eqnarray}\right.
                                \)
                            </td>
                            <td>
                                <table class="matrix-table">
                                    <tr>
                                        <td>
                                            <div class="dynamic-number-container" id="kalman-gain-state-measurement-space-0">1.0</div>
                                        </td>
                                    </tr>
                                </table>
                            </td>
                            <td>
                                , \( \measurementMatrix \stateCovariance \measurementMatrix^T = \)
                            </td>
                            <td>
                                <table class="matrix-table">
                                    <tr>
                                        <td>
                                            <div class="dynamic-number-container" id="kalman-gain-state-measurement-space-covariance-00">1.0</div>
                                        </td>
                                    </tr>
                                </table>
                            </td>
                            <td>
                                \( \left.
                                \begin{eqnarray}
                                \\
                                \\
                                \end{eqnarray}
                                \right) \)
                            </td>
                        </table>
                    </td>
                    <td>
                        <table class="kalman-gain-measurement-gaussian-expr math-diagram-structure-table">
                            <tr>
                                <td>\( \mathcal{N} \left( \measurement = 
                                    \begin{eqnarray}
                                    \\
                                    \\
                                    \end{eqnarray}\right. \)</td>
                                <td>
                                    <table class="matrix-table">
                                        <tr>
                                            <td>
                                                <draggable-number id="kalman-gain-measurement-0" min="-4" max="4" step="0.01" value="-1">-1.0</draggable-number>
                                            </td>
                                        </tr>
                                    </table>
                                </td>
                                <td>, \( \measurementNoiseCovariance = \)</td>
                                <td>
                                    <table class="matrix-table">
                                        <tr>
                                            <td>
                                                <draggable-number id="kalman-gain-measurement-covariance-00" min="0" max="5" step="0.01" value="1">1.0</draggable-number>
                                            </td>
                                        </tr>
                                    </table>
                                </td>
                                <td>\( \left.
                                    \begin{eqnarray}
                                    \\
                                    \\
                                    \end{eqnarray}
                                    \right) \)</td>
                            </tr>
                        </table>
                    </td>
                </tr>
                <tr class="kalman-gain-measurement-space">
                    <td style="font-size: 18px;">&#x2198;</td> <!-- down right arrow -->
                    <td style="font-size: 18px;">&#x2199;</td> <!-- down left arrow -->
                </tr>
                <tr class="kalman-gain-measurement-space"
                    style="border-top: 2px dashed black; border-right: 2px dashed black; border-left: 2px dashed black;">
                    <td colspan="2">
                        <table class="math-diagram-structure-table">
                            <tr>
                                <td>
                                    <table class="math-diagram-structure-table">
                                        <tr>
                                            <td>
                                                \( \varianceRatio = \frac{\measurementMatrix \stateCovariance \measurementMatrix^T}{\measurementMatrix \stateCovariance \measurementMatrix^T + \measurementNoiseCovariance} = \)
                                            </td>
                                            <td>
                                                <table class="matrix-table">
                                                    <tr>
                                                        <td>
                                                            <div class="dynamic-number-container" id="kalman-gain-variance-ratio-00">1.0</div>
                                                        </td>
                                                    </tr>
                                                </table>
                                            </td>
                                        </tr>
                                    </table>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <table class="math-diagram-structure-table kalman-gain-combined-gaussian-expr">
                                        <tr>
                                            <td>
                                                \(\mathcal{N} \left( (I-\varianceRatio)\measurementMatrix + \varianceRatio \measurement \text{, } \space \space \space (I-\varianceRatio) \measurementMatrix \stateCovariance \measurementMatrix^T (I-\varianceRatio)^T + \varianceRatio \measurementNoiseCovariance \varianceRatio^T \right) \)
                                            </td>
                                        </tr>
                                    </table>
                                </td>
                            </tr>
                        </table>
                    </td>
                </tr>
                <tr class="kalman-gain-measurement-space"
                    style="border-right: 2px dashed black; border-left: 2px dashed black;">
                    <td colspan="2">
                        <div id="measurement-kalman-gain-plot" class="figure-plot"></div>
                    </td>
                </tr>
                <tr class="kalman-gain-intermediate-space"
                    style="border-right: 2px dashed black; border-left: 2px dashed black;">
                    <td colspan="2" style="font-size: 24px;">&#x2193;</td> <!-- Down arrow -->
                </tr>
                <tr class="kalman-gain-intermediate-space"
                    style="border-bottom: 2px dashed black; border-right: 2px dashed black; border-left: 2px dashed black;">
                    <td colspan="2">
                        Convert back to state space with \( \measurementMatrix^{-1} \)
                    </td>
                </tr>
                <tr class="kalman-gain-intermediate-space">
                    <td colspan="2" style="font-size: 24px;">&#x2193;</td> <!-- Down arrow -->
                </tr>
                <tr class="kalman-gain-state-space">
                    <td colspan="2">
                        <table class="math-diagram-structure-table">
                            <tr>
                                <td>\(\text{New State Estimate (not plotted): } \mathcal{N} \left( 
                                    \begin{eqnarray}
                                    \\
                                    \state_{\discreteTime} \\
                                    \\
                                \end{eqnarray}
                                \right. =\)
                                <td>
                                    <table class="matrix-table" id="kalman-gain-new-state">
                                        <tr>
                                            <td>
                                                <div class="dynamic-number-container" id="kalman-gain-new-state-0">1.0</div>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>
                                                <div class="dynamic-number-container" id="kalman-gain-new-state-1">1.0</div>
                                            </td>
                                        </tr>
                                    </table>
                                </td>
                                <td>, \( \stateCovariance_{\discreteTime} = \)</td>
                                <td>
                                    <table class="matrix-table" id="kalman-gain-new-state-covariance">
                                        <tr>
                                            <td>
                                                <div class="dynamic-number-container" id="kalman-gain-new-state-covariance-00">1.0</div>
                                            </td>
                                            <td>
                                                <div class="dynamic-number-container" id="kalman-gain-new-state-covariance-01">0.0</div>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>
                                                <div class="dynamic-number-container" id="kalman-gain-new-state-covariance-10">0.0</div>
                                            </td>
                                            <td>
                                                <div class="dynamic-number-container" id="kalman-gain-new-state-covariance-11">1.0</div>
                                            </td>
                                        </tr>
                                    </table>
                                </td>
                                <td>\( \left. 
                                        \begin{eqnarray}
                                        \\
                                        \\
                                        \\
                                    \end{eqnarray}
                                    \right) \)
                                </td>
                            </tr>
                        </table>
                    </td>
                </tr>
                <tr class="kalman-gain-state-space">
                    <td colspan="2" style="padding: 5px;"></td>
                </tr>
            </table>
            <script>
                (function() { // Immediately Invoked Function Expression (IIFE)
                //// Make variables for the elements on the page
                // Draggable Elements
                const xtm1_0 = document.getElementById("kalman-gain-old-state-0");
                const xtm1_1 = document.getElementById("kalman-gain-old-state-1");
                const Ptm1_00 = document.getElementById("kalman-gain-old-state-covariance-00");
                const Ptm1_01 = document.getElementById("kalman-gain-old-state-covariance-01");
                const Ptm1_11 = document.getElementById("kalman-gain-old-state-covariance-11");
                const z_0 = document.getElementById("kalman-gain-measurement-0");
                const R_00 = document.getElementById("kalman-gain-measurement-covariance-00");
                
                // Not Draggable, but still dynamic elements
                const Ptm1_10 = document.getElementById("kalman-gain-old-state-covariance-10");
                const Hx_0 = document.getElementById("kalman-gain-state-measurement-space-0");
                const HPH_00 = document.getElementById("kalman-gain-state-measurement-space-covariance-00");
                const VR_00 = document.getElementById("kalman-gain-variance-ratio-00");
                const xt_0 = document.getElementById("kalman-gain-new-state-0");
                const xt_1 = document.getElementById("kalman-gain-new-state-1");
                const P_00 = document.getElementById("kalman-gain-new-state-covariance-00");
                const P_01 = document.getElementById("kalman-gain-new-state-covariance-01");
                const P_10 = document.getElementById("kalman-gain-new-state-covariance-10");
                const P_11 = document.getElementById("kalman-gain-new-state-covariance-11");
                
                //// Make the old state covariance be positive semi-definite and symmetric
                Ptm1_00.setValidityCondition((newValue) => {
                    return isPositiveSemiDefinite([[newValue, Ptm1_01.value], [Ptm1_01.value, Ptm1_11.value]])
                });
                Ptm1_01.setValidityCondition((newValue) => {
                    return isPositiveSemiDefinite([[Ptm1_00.value, newValue], [newValue, Ptm1_11.value]])
                });
                Ptm1_11.setValidityCondition((newValue) => {
                    return isPositiveSemiDefinite([[Ptm1_00.value, Ptm1_01.value], [Ptm1_01.value, newValue]])
                });
        
        
                //// Update the matrices whenever one is changed
                function updateKalmanGainDiagram() {
                    const xtm1 = [[xtm1_0.value], [xtm1_1.value]];
                    // Note: Ptm1_01 is always used instead of Ptm1_10 because the matrix is symmetric
                    const Ptm1 = [[Ptm1_00.value, Ptm1_01.value], [Ptm1_01.value, Ptm1_11.value]];
                    const z = [[z_0.value]];
                    const R = [[R_00.value]];
                    const H = [[1,0]]; // TODO shrink figure above
                    const Hx = matMul(H, xtm1);
                    const HPH = matMul(matMul(H, Ptm1), matTranspose(H));
                    const K = KalmanGain(Ptm1, H, R);
                    // VRz is exactly the same as VRx but the order of multiplication is flipped
                    const VRz = matMul(H, K);
                    const [xt, Pt] = KalmanUpdateStep(xtm1, Ptm1, H, z, R);
                    
                    VR_00.textContent = VRz[0][0].toFixed(2);
                    Hx_0.textContent = Hx[0][0].toFixed(2);
                    HPH_00.textContent = HPH[0][0].toFixed(2);
                    xt_0.textContent = xt[0][0].toFixed(2);
                    xt_1.textContent = xt[1][0].toFixed(2);
                    P_00.textContent = Pt[0][0].toFixed(2);
                    P_01.textContent = Pt[0][1].toFixed(2);
                    P_10.textContent = Pt[1][0].toFixed(2);
                    P_11.textContent = Pt[1][1].toFixed(2);
                    Ptm1_10.textContent = Ptm1_01.value.toFixed(2);
        
                    updateKalmanGainPlot(Hx[0][0], HPH[0][0], z[0][0], R[0][0], xt[0][0], Pt[0][0]);
                }
        
                //// Generate a plot of the three univariate gausians: Hx_{t-1}, z, and Hx_{t}
        
                const xmin = -4;
                const xmax = 4; 
                function updateKalmanGainPlot(Hx_tm1_mean, 
                                            Hx_tm1_var,
                                            z_mean,
                                            z_var,
                                            Hx_t_mean,
                                            Hx_t_var) {
        
                    [x_Hx_tm1, y_Hx_tm1] = univariateGaussianXYpts(Hx_tm1_mean, Hx_tm1_var, xAbsMin=xmin, xAbsMax=xmax, yAbsMax=1.5);
                    [x_z, y_z] = univariateGaussianXYpts(z_mean, z_var, xAbsMin=xmin, xAbsMax=xmax, yAbsMax=1.5);
                    [x_Hx_t, y_Hx_t] = univariateGaussianXYpts(Hx_t_mean, Hx_t_var, xAbsMin=xmin, xAbsMax=xmax, yAbsMax=1.5);
        
                    const trace_Hx_tm1 = {
                        x: x_Hx_tm1, 
                        y: y_Hx_tm1,
                        type: 'scatter',
                        mode: 'lines',
                        name: 'Previous State in Measurement Space',
                        line: {color: 'blue'},
                    };
                    const trace_z = {
                        x: x_z, 
                        y: y_z,
                        type: 'scatter',
                        mode: 'lines',
                        name: 'Measurement',
                        line: {color: 'green'},
                    };
                    const trace_Hx_t = {
                        x: x_Hx_t, 
                        y: y_Hx_t,
                        type: 'scatter',
                        mode: 'lines',
                        name: 'Combination',
                        line: {color: 'red'},
                    };
                    const backgroundColor = getComputedStyle(document.querySelector('.kalman-gain-measurement-space')).backgroundColor;
                    const layout = {
                        title: 'Kalman Gain Probability Densities (Measurement Space)',
                        legend: {
                            orientation: 'h',
                            yanchor: 'top',
                            xanchor: 'center',
                            y: 1.05,
                            x: 0.5,
                        },
                        yaxis: {
                            title: 'Probability',
                            range: [0, 1.3]
                        },
                        xaxis: {
                            title: 'Position',
                            range: [xmin, xmax]
                        },
                        // width: '100%',
                        // aspectratio: {x: 1, y: 1},  // Ensure the aspect ratio is 1:1
                        margin: {
                            l: 40,
                            r: 40,
                            t: 50,
                            b: 40,
                        },
                        hovermode: 'closest',
                        plot_bgcolor: backgroundColor,
                        paper_bgcolor: backgroundColor
                    };
                    
                    Plotly.react('measurement-kalman-gain-plot', [trace_Hx_tm1, trace_z, trace_Hx_t], layout);
                }
                updateKalmanGainDiagram();
        
                // Add event listeners to all the draggable elements
                [xtm1_0, xtm1_1, Ptm1_00, Ptm1_01, Ptm1_11, z_0, R_00].forEach(el => el.addEventListener("input", () => {
                    updateKalmanGainDiagram();
                }));
        
            })(); // IIFE
            </script>
        </div>
    </div>

    <div id="update-step-option2" class="expanded-content-long">
        <p>
            The other way we could approach combining the measurement distribution 
            with the state estimate distribution can be outlined as follows:
            <ol>
                <li>See what states could have led to the measurement we got</li>
                <li>Combine this with our current state estimate</li>
            </ol>
        </p>
        <p>Let's break this down. </p>

        <p> In order to put our two distributions on the same footing, we'll multiply the
            measurement distribution by \( \measurementMatrix^{-1} \) to bring it into 
            the space of states. Remembering our 
            <span class="expandable-content-text" onclick="toggleExpandableContent('duplicate-gaussian-multiplication-rule-2')">
                rule for multiplying gaussians</span>, we'll get two normal distributions in the same space:
        <div class="expanded-content" id="duplicate-gaussian-multiplication-rule-2"></div>
        </p>
            <ul>
                <li>The state distribution from the prediction step:\( \gaussian \left( \state, \space \stateCovariance \right) \)</li>
                <li>The state distribution inferred from the actual measurement: \( \gaussian \left( \measurementMatrix^{-1} \measurement, \space \space \measurementMatrix^{-1} \measurementNoiseCovariance (\measurementMatrix^{-1})^T \right) \)</li>
            </ul>
        <p>
            (If you see something wrong here, suspend your disbelief and read on ... )
        </p>
        <div id="duplicate-what-we-want-of-gaussians"></div>
        <p>But how much, exactly, of each estimate do we want to use? One reasonable approach is to weight each distribution 
            by the inverse of its variance, so the distribution with less uncertainty (ie. smaller variance) will play more of a role.
            To write this mathematically, we first define the variance ratio (in the space of states):
            $$ \varianceRatioState = \frac{\stateCovariance}{\stateCovariance + \measurementMatrix^{-1} \measurementNoiseCovariance (\measurementMatrix^{-1})^T} =
            \frac{\text{Uncertainty from state estimate}}{\text{Total uncertainty from the state estimate and sensor noise}} $$
        </p>
        <p class="expandable-content-text" onclick="toggleExpandableContent('matrix-fractions-explanation-2')">
            Wait, you can write a matrix inverse like a fraction?!
        </p>
        <p class="expanded-content" id="matrix-fractions-explanation-2"></p>
        
        <p class="expandable-content-text" onclick="toggleExpandableContent('bayes-rule-explanation-2')">
            Is there a deeper mathematical reason why we use the variance ratio?
        </p>
        <p class="expanded-content" id="bayes-rule-explanation-2"></p>

        <p>Then we can use this to write a weighted sum of each distribution:</p>
        <p>
            $$ \state = (\identityMatrix - \varianceRatioState) \state + \varianceRatioState \measurementMatrix^{-1} \measurement $$
        </p>

        <p>
            Great! It seems like this weighted sum does exactly what we need.  
        </p>
        <p> 
            There's only one problem: \(\measurementMatrix\) is not necessarily square, so it 
            <span class="expandable-content-text" onclick="toggleExpandableContent('measurement-matrix-not-invertible')">cannot be inverted</span>. 
        </p>
        <img class="expanded-content" 
            id="measurement-matrix-not-invertible"
            src="./assets/Grus-plan-Measurement-Matrix-Not-Invertible.png" 
            alt="Gru's Plan meme: Measurement Matrix is not invertible" 
            style="max-width: 100%; height: auto;">

        <p> 
            Well, that kind of throws a wrench in everything. Fortunately, there is a workaround! 
            If we suspend our disbelief and do a bit of matrix algebra as if \( \measurementMatrix^{-1} \) exists,
            we can avoid ever having to invert the measurement matrix. We'll use the following identities:
            For any invertible matrices \(\mathbf{A}\), \(\mathbf{B}\) we have:
            \( (\mathbf{A} \mathbf{B})^{-1} = \mathbf{B}^{-1} \mathbf{A}^{-1} \), and
            \( (\mathbf{A}^{-1})^{-T} = (\mathbf{A}^T)^{-1} \), 
            and we can always multiply anywhere by the identity \( \identityMatrix = \measurementMatrix^{-1} \measurementMatrix = \measurementMatrix^T (\measurementMatrix^T)^{-1} \)
        </p>

        <p>
            So let's knock out those inverses!
            $$ \begin{align*}
            \varianceRatioState &= \stateCovariance \left[ \stateCovariance + \measurementMatrix^{-1} \measurementNoiseCovariance \left( \measurementMatrix^{-1} \right)^T \right]^{-1} \\
            &= \stateCovariance \left[ \stateCovariance + \measurementMatrix^{-1} \measurementNoiseCovariance \left( \measurementMatrix^{-1} \right)^T \right]^{-1} \left( \measurementMatrix^{-1} \measurementMatrix \right)\\
            &= \stateCovariance \left[ \measurementMatrix \left( \stateCovariance + \measurementMatrix^{-1} \measurementNoiseCovariance \left( \measurementMatrix^{-1} \right)^T \right) \right]^{-1} \measurementMatrix \\
            &= \stateCovariance \left[ \measurementMatrix \stateCovariance + \measurementNoiseCovariance \left( \measurementMatrix^{-1} \right)^T \right]^{-1} \measurementMatrix \\
            &= \stateCovariance \left( \measurementMatrix^T \left( \measurementMatrix^T \right)^{-1} \right) \left[ \measurementMatrix \stateCovariance + \measurementNoiseCovariance \left( \measurementMatrix^{-1} \right)^T \right]^{-1} \measurementMatrix \\
            &= \stateCovariance \measurementMatrix^T \left[ \left( \measurementMatrix \stateCovariance + \measurementNoiseCovariance \left( \measurementMatrix^{-1} \right)^T \right) \measurementMatrix^T \right]^{-1} \measurementMatrix \\
            \varianceRatioState &= \stateCovariance \measurementMatrix^T \left[ \measurementMatrix \stateCovariance \measurementMatrix^T + \measurementNoiseCovariance \right]^{-1} \measurementMatrix \\
            \end{align*}
            $$
        </p>
        <p> Now our Variance ratio is free of \( \measurementMatrix^{-1} \), but there is still one 
            more remaining in the weighted sum formula. In preparation to eliminate this remaining 
            \( \measurementMatrix^{-1} \), we'll separate out the trailing \( \measurementMatrix \) 
            from the rest of the formula. The variance ratio without the trailing \( \measurementMatrix \) 
            is actually so important that we'll give it a name:
            $$ \text{The Kalman Gain } \kalmanGain = \stateCovariance \measurementMatrix^T \left[ \measurementMatrix \stateCovariance \measurementMatrix^T + \measurementNoiseCovariance \right]^{-1} $$
            Then we can write the variance ratio as:
            $$ \varianceRatioState = \kalmanGain \measurementMatrix $$
        </p>

        <p>
            Now we can proceed in writing our state update equation without any remaining \( \measurementMatrix^{-1} \):
            $$ \begin{align*}
            \state &= (\identityMatrix - \varianceRatioState) \state + \varianceRatioState \measurementMatrix^{-1} \measurement \\
            \state &= \left( \identityMatrix - \kalmanGain \measurementMatrix \right) \state + \kalmanGain \measurement \\
            \end{align*}
            $$
        </p>

        <p> Great! Now we have a matrix formula to combine the means of two Gaussians. The only step left is to propagate the variances too,
            which we can easily do using our <span class="expandable-content-text" onclick="toggleExpandableContent('duplicate-gaussian-multiplication-rule-3')">
                rule for multiplying Gaussians</span>. 
        </p>
        <div class="expanded-content" id="duplicate-gaussian-multiplication-rule-3"></div>

        <p>
            $$ \stateCovariance_{\discreteTime} = 
                \left( \identityMatrix - \kalmanGain \measurementMatrix \right) 
                \stateCovariance_{\discreteTime-1} 
                \left( \identityMatrix - \kalmanGain \measurementMatrix \right)^T + 
                \kalmanGain \measurementNoiseCovariance \kalmanGain^T 
            $$
        <p>The equation above is known as the Joseph Form of the Covariance Update Equation.
            <span class="expandable-content-text" onclick="toggleExpandableContent('covariance-matrix-simplification-2')">
                There is also a simpler (though less numerically stable) form of this equation.
            </span>
        </p>
        <div class="expanded-content" id="covariance-matrix-simplification-2"></div>

        <p>
            Here's an interactive diagram to visualize the whole process. 
            The work done by the Kalman Gain is surrounded by a dashed box.
            Try sliding the underlined variables around to see how they affect the outcome!
        </p>
        <div id="state-kalman-gain-diagram">
            <table class="math-diagram-structure-table">
                <tr class="kalman-gain-state-space">
                    <th colspan="2" style="font-size: 1.3rem; padding: 10px;">Update Step (State Space)</th>
                </tr>
                <tr class="kalman-gain-state-space">
                    <td>
                        <table class="math-diagram-structure-table">
                            <tr>
                                <td>\( \mathcal{N} \left( 
                                    \begin{eqnarray}
                                    \\
                                    \state_{\discreteTime - 1} \\
                                    \\
                                \end{eqnarray}
                                \right. =\)
                                <td>
                                    <table class="matrix-table">
                                        <tr>
                                            <td>
                                                <draggable-number id="xkalman-gain-old-state-0" min="-3" max="3" step="0.01" value="1">1.0</draggable-number>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>
                                                <draggable-number id="xkalman-gain-old-state-1" min="-3" max="3" step="0.01" value="0">0.0</draggable-number>
                                            </td>
                                        </tr>
                                    </table>
                                </td>
                                <td>, \( \stateCovariance_{\discreteTime-1} = \)</td>
                                <td>
                                    <table class="matrix-table">
                                        <tr>
                                            <td>
                                                <draggable-number id="xkalman-gain-old-state-covariance-00" min="0" max="4" step="0.01" value="0.5">0.5</draggable-number>
                                            </td>
                                            <td>
                                                <draggable-number id="xkalman-gain-old-state-covariance-01" min="-3" max="3" step="0.01" value="0.0">0.0</draggable-number>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>
                                                <div class="dynamic-number-container" id="xkalman-gain-old-state-covariance-10">0.0</div>
                                            </td>
                                            <td>
                                                <draggable-number id="xkalman-gain-old-state-covariance-11" min="0" max="4" step="0.01" value="0.5">0.5</draggable-number>
                                            </td>
                                        </tr>
                                    </table>
                                </td>
                                <td>\( \left. 
                                        \begin{eqnarray}
                                        \\
                                        \\
                                        \\
                                    \end{eqnarray}
                                    \right) \)
        
                            </tr>
                        </table>
                    </td>
                    <td></td>
                </tr>
                <tr class="kalman-gain-intermediate-space">
                    <td style="font-size: 24px;">&#x2193;</td> <!-- Down arrow -->
                    <td></td>
                </tr>
                <tr class="kalman-gain-intermediate-space">
                    <td>
                        Convert to Measurement Space with
                        \( \measurementMatrix = \begin{bmatrix} 1 & 0 \end{bmatrix} \)
                    </td>
                    <td></td>
                </tr>
                <tr class="kalman-gain-intermediate-space">
                    <td style="font-size: 24px;">&#x2193;</td> <!-- Down arrow -->
                    <td></td>
                </tr>
                <tr class="kalman-gain-measurement-space">
                    <td>
                        <table class="math-diagram-structure-table">
                            <td>
                                \(\mathcal{N} \left( \measurementMatrix \state_{\discreteTime-1} = 
                                \begin{eqnarray}
                                \\
                                \\
                                \end{eqnarray}\right.
                                \)
                            </td>
                            <td>
                                <table class="matrix-table">
                                    <tr>
                                        <td>
                                            <div class="dynamic-number-container" id="xkalman-gain-state-measurement-space-0">1.0</div>
                                        </td>
                                    </tr>
                                </table>
                            </td>
                            <td>
                                , \( \measurementMatrix \stateCovariance \measurementMatrix^T = \)
                            </td>
                            <td>
                                <table class="matrix-table">
                                    <tr>
                                        <td>
                                            <div class="dynamic-number-container" id="xkalman-gain-state-measurement-space-covariance-00">1.0</div>
                                        </td>
                                    </tr>
                                </table>
                            </td>
                            <td>
                                \( \left.
                                \begin{eqnarray}
                                \\
                                \\
                                \end{eqnarray}
                                \right) \)
                            </td>
                        </table>
                    </td>
                    <td>
                        <table class="math-diagram-structure-table">
                            <tr>
                                <td>\( \mathcal{N} \left( \measurement = 
                                    \begin{eqnarray}
                                    \\
                                    \\
                                    \end{eqnarray}\right. \)</td>
                                <td>
                                    <table class="matrix-table">
                                        <tr>
                                            <td>
                                                <draggable-number id="xkalman-gain-measurement-0" min="-3" max="3" step="0.01" value="-1">-1.0</draggable-number>
                                            </td>
                                        </tr>
                                    </table>
                                </td>
                                <td>, \( \measurementNoiseCovariance = \)</td>
                                <td>
                                    <table class="matrix-table">
                                        <tr>
                                            <td>
                                                <draggable-number id="xkalman-gain-measurement-covariance-00" min="0" max="3" step="0.01" value="0.3">0.3</draggable-number>
                                            </td>
                                        </tr>
                                    </table>
                                </td>
                                <td>\( \left.
                                    \begin{eqnarray}
                                    \\
                                    \\
                                    \end{eqnarray}
                                    \right) \)</td>
                            </tr>
                        </table>
                    </td>
                </tr>
                <tr class="kalman-gain-measurement-space">
                    <td style="font-size: 24px;">&#x2193;</td> <!-- Down arrow -->
                    <td style="font-size: 24px;">&#x2193;</td> <!-- Down arrow -->
                </tr>
                <tr class="kalman-gain-intermediate-space"
                    style="border-top: 2px dashed black; border-right: 2px dashed black; border-left: 2px dashed black;">
                    <td colspan="2">
                        Convert to state space with \( \measurementMatrix^{-1} \)
                    </td>
                </tr>
                <tr class="kalman-gain-state-space"
                    style="border-right: 2px dashed black; border-left: 2px dashed black;">
                    <td style="font-size: 24px;">&#x2193;</td> <!-- Down arrow -->
                    <td style="font-size: 24px;">&#x2193;</td> <!-- Down arrow -->
                </tr>
                <tr class="kalman-gain-state-space"
                    style="border-right: 2px dashed black; border-left: 2px dashed black;">
                    <td>
                        <table class="math-diagram-structure-table kalman-gain-state-gaussian-expr">
                            <tr>
                                <td>\( \mathcal{N} \left( 
                                    \begin{eqnarray}
                                    \\
                                    \state_{\discreteTime - 1} \\
                                    \\
                                \end{eqnarray}
                                \right. =\)
                                <td>
                                    <table class="matrix-table">
                                        <tr>
                                            <td>
                                                <div class="dynamic-number-container" id="xkalman-gain-old-state-d-0">0.0</div>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>
                                                <div class="dynamic-number-container" id="xkalman-gain-old-state-d-1">0.0</div>
                                            </td>
                                        </tr>
                                    </table>
                                </td>
                                <td>, \( \stateCovariance_{\discreteTime-1} = \)</td>
                                <td>
                                    <table class="matrix-table">
                                        <tr>
                                            <td>
                                                <div class="dynamic-number-container" id="xkalman-gain-old-state-covariance-d-00">0.0</div>
                                            </td>
                                            <td>
                                                <div class="dynamic-number-container" id="xkalman-gain-old-state-covariance-d-01">0.0</div>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>
                                                <div class="dynamic-number-container" id="xkalman-gain-old-state-covariance-d-10">0.0</div>
                                            </td>
                                            <td>
                                                <div class="dynamic-number-container" id="xkalman-gain-old-state-covariance-d-11">0.0</div>
                                            </td>
                                        </tr>
                                    </table>
                                </td>
                                <td>\( \left. 
                                        \begin{eqnarray}
                                        \\
                                        \\
                                        \\
                                    \end{eqnarray}
                                    \right) \)
        
                            </tr>
                        </table>
                    </td>
                    <td>
                        <table class="kalman-gain-measurement-gaussian-expr math-diagram-structure-table">
                            <tr>
                                <td>\( \mathcal{N} \left( \measurementMatrix^{-1} \measurement = 
                                    \begin{eqnarray}
                                    \\
                                    \\
                                    \\
                                    \end{eqnarray}\right. \)</td>
                                <td>
                                    <table class="matrix-table">
                                        <tr>
                                            <td>
                                                <div class="dynamic-number-container" id="xkalman-gain-Hz-0">0.0</div>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>-</td>
                                        </tr>
                                    </table>
                                </td>
                                <td>, \( \measurementMatrix^{-1} \measurementNoiseCovariance \left( \measurementMatrix^{-1} \right)^T = \)</td>
                                <td>
                                    <table class="matrix-table">
                                        <tr>
                                            <td>
                                                <div class="dynamic-number-container" id="xkalman-gain-HRH-00">0.0</div>
                                            </td>
                                            <td>-</td>
                                        </tr>
                                        <tr>
                                            <td>-</td>
                                            <td>-</td>
                                        </tr>
                                    </table>
                                </td>
                                <td>\( \left.
                                    \begin{eqnarray}
                                    \\
                                    \\
                                    \\
                                    \end{eqnarray}
                                    \right) \)</td>
                            </tr>
                        </table>
                    </td>
                </tr>
                <tr class="kalman-gain-state-space"
                    style="border-right: 2px dashed black; border-left: 2px dashed black;">
                    <td colspan="2">
                        <table class="math-diagram-structure-table">
                            <tr>
                                <td>
                                    <table class="math-diagram-structure-table">
                                        <tr>
                                            <td>
                                                \( \varianceRatioState 
                                                      = \frac{\stateCovariance}{\stateCovariance + \measurementMatrix^{-1} \measurementNoiseCovariance (\measurementMatrix^{-1})^T} 
                                                      = \stateCovariance \measurementMatrix^T \left[ \measurementMatrix \stateCovariance \measurementMatrix^T + \measurementNoiseCovariance \right]^{-1} \measurementMatrix =
                                                \)
                                            </td>
                                            <td>
                                                <table class="matrix-table">
                                                    <tr>
                                                        <td>
                                                            <div class="dynamic-number-container" id="kalman-gain-variance-ratio-00">1.0</div>
                                                        </td>
                                                        <td>
                                                            <div class="dynamic-number-container" id="kalman-gain-variance-ratio-01">1.0</div>
                                                        </td>
                                                    </tr>
                                                    <tr>
                                                        <td>
                                                            <div class="dynamic-number-container" id="kalman-gain-variance-ratio-10">1.0</div>
                                                        </td>
                                                        <td>
                                                            <div class="dynamic-number-container" id="kalman-gain-variance-ratio-11">1.0</div>
                                                        </td>
                                                    </tr>
                                                </table>
                                            </td>
                                        </tr>
                                    </table>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <table class="math-diagram-structure-table kalman-gain-combined-gaussian-expr">
                                        <tr>
                                            <td>
                                                \( \mathcal{N} \left( (I - \varianceRatioState) \state + \varianceRatioState \measurementMatrix^{-1} \measurement
                                                \text{, } \space \space \space 
                                                (I-\varianceRatioState) \stateCovariance (I-\varianceRatioState)^T + (\varianceRatioState \measurementMatrix^{-1}) \measurementNoiseCovariance (\varianceRatioState \measurementMatrix^{-1})^T \right) \)
                                            </td>
                                        </tr>
                                    </table>
                                </td>
                            </tr>
                        </table>
                    </td>
                </tr>
                <tr class="kalman-gain-state-space"
                    style="border-bottom: 2px dashed black; border-right: 2px dashed black; border-left: 2px dashed black;">
                    <td colspan="2">
                        <div id="state-kalman-gain-plot" class="figure-plot"></div>
                    </td>
                </tr>
                <tr class="kalman-gain-state-space">
                    <td colspan="2" style="font-size: 24px;">&#x2193;</td> <!-- Down arrow -->
                </tr>
        
                <tr class="kalman-gain-state-space">
                    <td colspan="2">
                        <table class="math-diagram-structure-table kalman-gain-combined-gaussian">
                            <tr>
                                <td>\(\text{New State Estimate: } \mathcal{N} \left( 
                                    \begin{eqnarray}
                                    \\
                                    \state_{\discreteTime} \\
                                    \\
                                \end{eqnarray}
                                \right. =\)
                                <td>
                                    <table class="matrix-table">
                                        <tr>
                                            <td>
                                                <div class="dynamic-number-container" id="xkalman-gain-new-state-0">1.0</div>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>
                                                <div class="dynamic-number-container" id="xkalman-gain-new-state-1">1.0</div>
                                            </td>
                                        </tr>
                                    </table>
                                </td>
                                <td>, \( \stateCovariance_{\discreteTime} = \)</td>
                                <td>
                                    <table class="matrix-table">
                                        <tr>
                                            <td>
                                                <div class="dynamic-number-container" id="xkalman-gain-new-state-covariance-00">1.0</div>
                                            </td>
                                            <td>
                                                <div class="dynamic-number-container" id="xkalman-gain-new-state-covariance-01">0.0</div>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>
                                                <div class="dynamic-number-container" id="xkalman-gain-new-state-covariance-10">0.0</div>
                                            </td>
                                            <td>
                                                <div class="dynamic-number-container" id="xkalman-gain-new-state-covariance-11">1.0</div>
                                            </td>
                                        </tr>
                                    </table>
                                </td>
                                <td>\( \left. 
                                        \begin{eqnarray}
                                        \\
                                        \\
                                        \\
                                    \end{eqnarray}
                                    \right) \)
                                </td>
                            </tr>
                        </table>
                    </td>
                </tr>
                <tr class="kalman-gain-state-space">
                    <td colspan="2" style="padding: 5px;"></td>
                </tr>
            </table>
            <script>
            (function() { // Immediately Invoked Function Expression (IIFE)
                //// Make variables for the elements on the page
                // Draggable Elements
                const xtm1_0 = document.getElementById("xkalman-gain-old-state-0");
                const xtm1_1 = document.getElementById("xkalman-gain-old-state-1");
                const Ptm1_00 = document.getElementById("xkalman-gain-old-state-covariance-00");
                const Ptm1_01 = document.getElementById("xkalman-gain-old-state-covariance-01");
                const Ptm1_11 = document.getElementById("xkalman-gain-old-state-covariance-11");
                const z_0 = document.getElementById("xkalman-gain-measurement-0");
                const R_00 = document.getElementById("xkalman-gain-measurement-covariance-00");
                
                // Not Draggable, but still dynamic elements
                const Ptm1_10 = document.getElementById("xkalman-gain-old-state-covariance-10");
                const Hx_0 = document.getElementById("xkalman-gain-state-measurement-space-0");
                const HPH_00 = document.getElementById("xkalman-gain-state-measurement-space-covariance-00");
                const VR_00 = document.getElementById("kalman-gain-variance-ratio-00");
                const VR_01 = document.getElementById("kalman-gain-variance-ratio-01");
                const VR_10 = document.getElementById("kalman-gain-variance-ratio-10");
                const VR_11 = document.getElementById("kalman-gain-variance-ratio-11");
                const xt_0 = document.getElementById("xkalman-gain-new-state-0");
                const xt_1 = document.getElementById("xkalman-gain-new-state-1");
                const P_00 = document.getElementById("xkalman-gain-new-state-covariance-00");
                const P_01 = document.getElementById("xkalman-gain-new-state-covariance-01");
                const P_10 = document.getElementById("xkalman-gain-new-state-covariance-10");
                const P_11 = document.getElementById("xkalman-gain-new-state-covariance-11");
                const xtm1_0_d = document.getElementById("xkalman-gain-old-state-d-0");
                const xtm1_1_d = document.getElementById("xkalman-gain-old-state-d-1");
                const Ptm1_00_d = document.getElementById("xkalman-gain-old-state-covariance-d-00");
                const Ptm1_01_d = document.getElementById("xkalman-gain-old-state-covariance-d-01");
                const Ptm1_10_d = document.getElementById("xkalman-gain-old-state-covariance-d-10");
                const Ptm1_11_d = document.getElementById("xkalman-gain-old-state-covariance-d-11");
                const Hz_0 = document.getElementById("xkalman-gain-Hz-0");
                const HRH_00 = document.getElementById("xkalman-gain-HRH-00");
        
                //// Make the old state covariance be positive semi-definite and symmetric
                Ptm1_00.setValidityCondition((newValue) => {
                    return isPositiveSemiDefinite([[newValue, Ptm1_01.value], [Ptm1_01.value, Ptm1_11.value]])
                });
                Ptm1_01.setValidityCondition((newValue) => {
                    return isPositiveSemiDefinite([[Ptm1_00.value, newValue], [newValue, Ptm1_11.value]])
                });
                Ptm1_11.setValidityCondition((newValue) => {
                    return isPositiveSemiDefinite([[Ptm1_00.value, Ptm1_01.value], [Ptm1_01.value, newValue]])
                });
        
        
                //// Update the matrices whenever one is changed
                function updateKalmanGainDiagramX() {
                    const xtm1 = [[xtm1_0.value], [xtm1_1.value]];
                    // Note: Ptm1_01 is always used instead of Ptm1_10 because the matrix is symmetric
                    const Ptm1 = [[Ptm1_00.value, Ptm1_01.value], [Ptm1_01.value, Ptm1_11.value]];
                    const z = [[z_0.value]];
                    const R = [[R_00.value]];
                    const H = [[1,0]]; // TODO shrink figure above
                    const Hx = matMul(H, xtm1);
                    const HPH = matMul(matMul(H, Ptm1), matTranspose(H));
                    const K = KalmanGain(Ptm1, H, R);
                    // VRz is exactly the same as VRx but the order of multiplication is flipped
                    const VRx = matMul(K, H);
                    const [xt, Pt] = KalmanUpdateStep(xtm1, Ptm1, H, z, R);
                    const Hinvz_0 = z[0][0] / H[0][0];
                    const HinvR_00 = R_00.value / H[0][0] / H[0][0];
        
                    VR_00.textContent = VRx[0][0].toFixed(2);
                    VR_10.textContent = VRx[1][0].toFixed(2);
                    VR_01.textContent = VRx[0][1].toFixed(2);
                    VR_11.textContent = VRx[1][1].toFixed(2);
                    Hx_0.textContent = Hx[0][0].toFixed(2);
                    HPH_00.textContent = HPH[0][0].toFixed(2);
                    xt_0.textContent = xt[0][0].toFixed(2);
                    xt_1.textContent = xt[1][0].toFixed(2);
                    P_00.textContent = Pt[0][0].toFixed(2);
                    P_01.textContent = Pt[0][1].toFixed(2);
                    P_10.textContent = Pt[1][0].toFixed(2);
                    P_11.textContent = Pt[1][1].toFixed(2);
                    Ptm1_10.textContent = Ptm1_01.value.toFixed(2);
                    Hz_0.textContent = Hinvz_0.toFixed(2);
                    HRH_00.textContent = HinvR_00.toFixed(2);
                    // duplicates
                    xtm1_0_d.textContent = xtm1_0.value.toFixed(2);
                    xtm1_1_d.textContent = xtm1_1.value.toFixed(2);
                    Ptm1_00_d.textContent = Ptm1_00.value.toFixed(2);
                    Ptm1_01_d.textContent = Ptm1_01.value.toFixed(2);
                    Ptm1_10_d.textContent = Ptm1_01.value.toFixed(2);
                    Ptm1_11_d.textContent = Ptm1_11.value.toFixed(2);
        
                    updateKalmanGainPlotX(xtm1, Ptm1, Hinvz_0, HinvR_00, xt, Pt);
                }
        
                //// Generate a plot of the three univariate gausians: Hx_{t-1}, z, and Hx_{t}
        
                function updateKalmanGainPlotX(x_tm1_mean, 
                                            x_tm1_var,
                                            Hz_mean,
                                            Hz_var,
                                            x_t_mean,
                                            x_t_var) {
                    let trace_xtm1 = generateGaussianEllipticalContours(x_tm1_mean, x_tm1_var, color='blue', name='Previous State');
                    let trace_Hz = generateGaussianLinearContours(Hz_mean, Hz_var, color='green', name='Measurement');
                    let trace_x_t = generateGaussianEllipticalContours(x_t_mean, x_t_var, color='red', name='Combination');
        
                    let traces = trace_xtm1.concat(trace_Hz).concat(trace_x_t);
                    
                    const backgroundColor = getComputedStyle(document.querySelector('.kalman-gain-state-space')).backgroundColor;
                    const layout = {
                        title: 'Kalman Gain Probability Density Contours (State Space)',
                        legend: {
                            orientation: 'h',
                            yanchor: 'top',
                            xanchor: 'center',
                            y: 1.05,
                            x: 0.5,
                        },
                        yaxis: {
                            title: 'Velocity',
                            range: [-2, 2]
                        },
                        xaxis: {
                            title: 'Position',
                            range: [-3, 3]
                        },
                        margin: {
                            l: 40,
                            r: 40,
                            t: 50,
                            b: 40,
                        },
                        hovermode: 'closest',
                        plot_bgcolor: backgroundColor,
                        paper_bgcolor: backgroundColor
                    };
                    
                    Plotly.react('state-kalman-gain-plot', traces, layout);
                }
                updateKalmanGainDiagramX();
        
                // Add event listeners to all the draggable elements
                [xtm1_0, xtm1_1, Ptm1_00, Ptm1_01, Ptm1_11, z_0, R_00].forEach(el => el.addEventListener("input", () => {
                    updateKalmanGainDiagramX();
                }));
        
            })(); // IIFE
            </script>
        </div>
    </div>

    <h2>Bringing it all together</h2>
    <p>
        In each of our derivations, we've arrived at the same definition for the Kalman Gain: 
        $$ \text{The Kalman Gain } \kalmanGain = \stateCovariance \measurementMatrix^T \left( \measurementMatrix \stateCovariance \measurementMatrix^T + \measurementNoiseCovariance \right)^{-1} $$

        However, we have also shown that there are two different ways to interpret this formula (so 
        long as you imagine that \( \measurementMatrix^{-1} \) exists). Rearranging \( \varianceRatioState = \kalmanGain \measurementMatrix \)
        and \( \varianceRatio = \measurementMatrix \kalmanGain \) we have:
        $$ \kalmanGain = \measurementMatrix^{-1} \varianceRatio = \varianceRatioState \measurementMatrix^{-1} $$

        Therefore, we can choose to interpret the Kalman Gain as a two-step process that always takes measurements as inputs, then either:
        <ul>
            <li>weighs the input by the measurement-space variance ratio, then converts to state space</li>
            <li>converts the input to state space, then weighs it by the state-space variance ratio</li>
        </ul>
    </p>

    <h2>The Full Algorithm</h2>
    <h3>Eg. What you actually need to implement</h3>
    <p>Now that we have all the mathematical pieces of the Predict and Update steps, 
        we can write out the full algorithm! In practice, we write each step as a function that 
    takes the previous state estimate along with new information, and returns a new state estimate.  </p>
    </p>
    <table style="width: 100%; text-align: left;">
        <tr>
            <th>
                Predict(\( \state_{\discreteTime-1}, \space \stateCovariance_{\discreteTime-1}, \space \stateTransition, \space \controlMatrix, \space \controlInput_{\discreteTime}, \space \processNoiseCovariance \)):
            </th>
            <th>
                Update(\( \state_{\discreteTime-1}, \space \stateCovariance_{\discreteTime-1}, \space \measurementMatrix, \space \measurement_{\discreteTime}, \space \measurementNoiseCovariance \)):
            </th>
        </tr>
        <tr>
            <th>
                \(
                \begin{align}
                    \quad \quad \state_{\discreteTime} &= 
                        \stateTransition \state_{\discreteTime-1} + \controlMatrix \controlInput_{\discreteTime} \\
                    \quad \quad \stateCovariance_{\discreteTime} &= 
                        \stateTransition \stateCovariance_{\discreteTime-1} \stateTransition^T + \processNoiseCovariance \\
                \end{align}
                \)
            </th>
            <th>
                \(
                \begin{align}
                    \quad \quad \kalmanGain &= \stateCovariance_{\discreteTime-1} \measurementMatrix^T 
                        \left( \measurementMatrix \stateCovariance_{\discreteTime-1} \measurementMatrix^T + \measurementNoiseCovariance \right)^{-1} \\
                    \quad \quad \state_{\discreteTime} &= \state_{\discreteTime-1} + 
                        \kalmanGain \left( \measurement_{\discreteTime} - \measurementMatrix \state_{\discreteTime-1} \right) \\
                    \quad \quad \stateCovariance_{\discreteTime} &= 
                        \left( \identityMatrix - \kalmanGain \measurementMatrix \right) 
                \stateCovariance_{\discreteTime-1} 
                \left( \identityMatrix - \kalmanGain \measurementMatrix \right)^T + 
                    \kalmanGain \measurementNoiseCovariance \kalmanGain^T 
                \end{align}
                \)
            </th>
        </tr>
        <tr>
            <th>\(\quad \quad \text{return } \left( \state_{\discreteTime}, \space \stateCovariance_{\discreteTime} \right)
                \)
            </th>
            <th>\(\quad \quad \text{return } \left( \state_{\discreteTime}, \space \stateCovariance_{\discreteTime} \right)
                \)
            </th>
        </tr>
    </table>
    <p>
        A few notes:
        <ol>
            <li>You should be calling the Predict function as often as you can 
                (the dynamics never stops so neither should your blind estimate),
                but the update function can only be called when there is a new measurement. 
                If your sensor is fast, you might always call Predict immediately followed 
                by Update, but if your sensor is slow, 5 predict steps might go by with no update. 
            </li>
            <li>In more advanced implementations, you can define all of the matrices 
                (\(\stateTransition\), \(\controlMatrix\), \(\measurementMatrix\), etc.) to
                vary with time (they even may change nonlinearly as time progresses).
            </li>
            <li>We use the longer form of the covariance update formula (also known 
                as the Joseph Form) because it is numerically more stable (though on 
                a modern computer running for short time periods, the difference is negligible).
            </li>
        </ol>
    </p>

    <p>Let's see the full algorithm in action!</p>

    <div>
        <div id="full-kalman-filter-diagram">    
            <div class="animation-container">
                <!-- SVG Robot -->
                <svg
                    width="78.827438mm"
                    height="90.709648mm"
                    viewBox="0 0 78.827438 90.709648"
                    version="1.1"
                    class="animation-robot"
                    xml:space="preserve"
                    xmlns="http://www.w3.org/2000/svg"
                    xmlns:svg="http://www.w3.org/2000/svg"><defs
                    class="defs1" /><g
                    class="body-layer"
                    transform="translate(-22.948456,-89.841802)"><path
                        style="opacity:0.99;fill:#a9c2ff;stroke:#858585;stroke-width:0.315"
                        d="m 60,90 c 9.621514,-0.06872 27.937315,4.966259 35,20 4.885644,8.69531 7.13726,41.14576 3.852748,47.30871 -3.130752,5.87445 -32.595817,6.76909 -39.141815,6.62609 -5.654366,-0.0512 -28.523962,0.63944 -31.397083,-7.34956 -3.240816,-11.23592 6.026113,-21.40713 7.734165,-41.25892 C 36.681208,107.96705 32.12253,92.455092 60,90 Z"
                        class="body-blob" /><circle
                        style="opacity:0.99;fill:#dcdffc;fill-opacity:1;stroke:#858585;stroke-width:0.315"
                        class="eye-white"
                        cx="77.621758"
                        cy="111.97367"
                        r="9.547823" /><circle
                        style="opacity:1;fill:#0f113f;fill-opacity:1;stroke:#020202;stroke-width:0.495001;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                        class="eye-pupil"
                        cx="77.621758"
                        cy="111.97367"
                        r="2.6847837" /><g
                        class="ultrasonic-group"
                        transform="matrix(0.46871921,0,0,0.46871921,-27.37283,72.641369)"><path
                        class="rect6"
                        style="opacity:1;fill:#0f113f;fill-opacity:1;stroke:#858585;stroke-width:0.495001;stroke-linecap:square"
                        d="m 127.17951,61.399733 12.57342,10.103943 -0.0408,63.504364 -12.50358,-10.33231 z" /><g
                        class="ultrasonic-cylinder-1"><path
                            class="rect5"
                            style="opacity:1;fill:#bcc2cf;fill-opacity:1;stroke:#858585;stroke-width:0.495;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none"
                            d="m 121.33471,71.751176 c -0.48654,0 -0.8785,0.391438 -0.8785,0.877983 v 20.853507 c 0,0.486545 0.39196,0.877983 0.8785,0.877983 h 11.71867 v 0 c 2.05411,-6.42e-4 4.84521,-5.137415 4.84518,-11.304737 3e-5,-6.167322 -2.79107,-11.304094 -4.84518,-11.304736 v 0 z" /><ellipse
                            style="opacity:0.99;fill:#25282e;fill-opacity:1;stroke:#858585;stroke-width:0.769677"
                            class="path3"
                            cx="120.45645"
                            cy="83.1931"
                            rx="3.719537"
                            ry="11.167632" /></g><g
                        class="ultrasonic-cylinder-2"><path
                            class="path7"
                            style="opacity:1;fill:#bcc2cf;fill-opacity:1;stroke:#858585;stroke-width:0.495;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none"
                            d="m 121.33471,100.66893 c -0.48654,0 -0.8785,0.39144 -0.8785,0.87799 v 20.8535 c 0,0.48655 0.39196,0.87799 0.8785,0.87799 h 11.71867 v 0 c 2.05411,-6.4e-4 4.84521,-5.13742 4.84518,-11.30474 3e-5,-6.16732 -2.79107,-11.30409 -4.84518,-11.30474 v 0 z" /><ellipse
                            style="opacity:0.99;fill:#25282e;fill-opacity:1;stroke:#858585;stroke-width:0.769677"
                            class="ellipse7"
                            cx="120.45645"
                            cy="112.11086"
                            rx="3.719537"
                            ry="11.167632" /></g></g></g><g
                    class="wheel-layer"
                    transform="translate(-22.948456,-89.841802)"><g
                        class="front-wheel"
                        style="display:inline"
                        transform="translate(-49.063398,7.483203)"><circle
                        style="opacity:1;fill:#121212;fill-opacity:1;stroke:#020202;stroke-width:0.495001;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                        class="axle1"
                        cx="134.39388"
                        cy="156.62283"
                        r="1.7787484" /><circle
                        style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:4;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                        class="front-tire"
                        cx="134.39388"
                        cy="156.62283"
                        r="14.445418" /><circle
                        style="fill:none;fill-opacity:1;stroke:#020202;stroke-width:2.17772;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                        class="path9-9"
                        cx="134.39388"
                        cy="156.62283"
                        r="9.6793108" /><circle
                        style="fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                        class="circle9"
                        cx="134.39388"
                        cy="156.62283"
                        r="3.6967146" /><g
                        class="front-spokes-1"><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 134.39387,152.92612 v -5.9826"
                            class="path10" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 138.09059,156.62283 h 5.98259 v 0"
                            class="path11" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 134.39387,160.31955 v 5.98259"
                            class="path12" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 130.69716,156.62283 h -5.9826"
                            class="path13" /></g><g
                        class="front-spokes-2"
                        transform="rotate(45,134.39387,156.62284)"><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 134.39387,152.92612 v -5.9826"
                            class="path17" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 138.09059,156.62283 h 5.98259 v 0"
                            class="path18" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 134.39387,160.31955 v 5.98259"
                            class="path19" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 130.69716,156.62283 h -5.9826"
                            class="path20" /></g></g><g
                        class="rear-wheel"
                        style="display:inline"
                        transform="translate(-95,7.483203)"><circle
                        style="opacity:1;fill:#121212;fill-opacity:1;stroke:#020202;stroke-width:0.495001;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                        class="axle2"
                        cx="134.39388"
                        cy="156.62283"
                        r="1.7787484" /><circle
                        style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:4;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                        class="circle36"
                        cx="134.39388"
                        cy="156.62283"
                        r="14.445418" /><circle
                        style="fill:none;fill-opacity:1;stroke:#020202;stroke-width:2.17772;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                        class="circle37"
                        cx="134.39388"
                        cy="156.62283"
                        r="9.6793108" /><circle
                        style="fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                        class="circle38"
                        cx="134.39388"
                        cy="156.62283"
                        r="3.6967146" /><g
                        class="g41"><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 134.39387,152.92612 v -5.9826"
                            class="path38" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 138.09059,156.62283 h 5.98259 v 0"
                            class="path39" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 134.39387,160.31955 v 5.98259"
                            class="path40" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 130.69716,156.62283 h -5.9826"
                            class="path41" /></g><g
                        class="g45"
                        transform="rotate(45,134.39387,156.62284)"><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 134.39387,152.92612 v -5.9826"
                            class="path42" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 138.09059,156.62283 h 5.98259 v 0"
                            class="path43" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 134.39387,160.31955 v 5.98259"
                            class="path44" /><path
                            style="opacity:1;fill:none;fill-opacity:1;stroke:#020202;stroke-width:1.5;stroke-linecap:square;stroke-linejoin:miter;stroke-dasharray:none;stroke-opacity:1"
                            d="m 130.69716,156.62283 h -5.9826"
                            class="path45" /></g></g></g>
                    </svg>
            </div>
            <div id="full-kalman-filter-state-diagram"></div>
            <table class="math-diagram-structure-table">
                <tr>
                    <td>Control the robot's acceleration by dragging the number: \( \controlInput = \)</td>
                    <td>
                        <table class="matrix-table">
                            <tr>
                                <td>
                                    <draggable-number class="control-input-slider" min="-1" max="1" value="0.0" step="0.1"></draggable-number>
                                </td>
                            </tr>
                        </table>
                    </td>
                </tr>
                <tr>
                    <td>
                        <button class="start-button">Start</button>
                        <button class="stop-button">Stop</button>
                        <button class="reset-button">Reset</button>
                    </td>
                </tr>
            </table>
        </div>
            <script>
                (function() {
                const diagram = document.getElementById('full-kalman-filter-diagram');
                // Also need to change the Plotly id
                const robot = diagram.querySelector('.animation-robot');
                const slider = diagram.querySelector('.control-input-slider');
                const container = diagram.querySelector('.animation-container');
                const startButton = diagram.querySelector('.start-button');
                const stopButton = diagram.querySelector('.stop-button');
                const resetButton = diagram.querySelector('.reset-button');
    
                /////////////////////////////////////////////////////////////
                // Kalman Filter parameters + models
                const wheelRadius = 50; //px (didn't actually measure this)
                const maxVelocity = 400; //px/sec
                const maxAngularAcceleration = 5; //rad/sec^2
                const KF_dt_min = 0.2; //seconds (determines how often the Predict step runs)
                const meas_dt_min = 0.5; //seconds (determines how often the Update step runs)
    
                // Truestate variables
                let throttle;  // -1 to 1
                let x; //px/s
    
                // Estimated state variables
                let x_est;
                let P_est;
    
                function resetAllVariables() {
                    // Truestate variables
                    throttle = parseFloat(slider.value);  // -1 to 1
                    x = [[0], //px
                        [100]]; //px/s
    
                    // Estimated state variables
                    const initial_state_variance = 100;
                    x_est = x;
                    P_est = [[initial_state_variance,0],[0,initial_state_variance]];
                }
                resetAllVariables();
    
                /////////////////////////////////////////////////////////////
                /////////////////////////////////////////////////////////////
    
                // Pupil animation
                const frontWheel = robot.querySelector('.front-wheel');
                const rearWheel = robot.querySelector('.rear-wheel');
                const pupil = robot.querySelector('.eye-pupil');
                const eyeWhite = robot.querySelector('.eye-white');
    
                function updatePupilPosition(mouseX, mouseY) {
                    const eyeWhiteRect = eyeWhite.getBoundingClientRect();
                    const pupilRect = pupil.getBoundingClientRect();
                    // Calculate the center of the eye
                    const eyeCenterX = eyeWhiteRect.left + eyeWhiteRect.width / 2;
                    const eyeCenterY = eyeWhiteRect.top + eyeWhiteRect.height / 2;
        
                    // Calculate the angle between the eye center and the mouse position
                    const angle = Math.atan2(mouseY - eyeCenterY, mouseX - eyeCenterX);
                    const distance = Math.sqrt((mouseX - eyeCenterX) * (mouseX - eyeCenterX) + (mouseY - eyeCenterY) * (mouseY - eyeCenterY));
        
                    // Calculate the maximum distance the pupil can move from the center
                    const maxDistance = (eyeWhiteRect.width - pupilRect.width) / 2;
        
                    // Calculate the new position of the pupil
                    let pupilX = Math.cos(angle) * Math.min(distance, maxDistance);
                    let pupilY = Math.sin(angle) * Math.min(distance, maxDistance);
                    
                    // Apply the new position to the pupil
                    pupil.style.transform = `translate(${pupilX}px, ${pupilY}px)`;
                }
        
                // Add event listener for mouse movement
                container.addEventListener('mousemove', (e) => {
                    updatePupilPosition(e.clientX, e.clientY);
                });
    
                // Update velocity when the slider value changes
                slider.addEventListener('input', () => {
                    throttle = parseFloat(slider.value);
                });
    
                // State-space plot
                function updateStatePlot(x, x_est, P_est) {
                    // Inputs:
                    // x: true state (2x1 array)
                    // x_est: estimated state (2x1 array)
                    // P_est: estimated covariance (2x2 array)
                    // Check input shapes
                    if (!Array.isArray(x) || x.length !== 2 || !Array.isArray(x[0]) || x[0].length !== 1 ||
                        !Array.isArray(x_est) || x_est.length !== 2 || !Array.isArray(x_est[0]) || x_est[0].length !== 1 ||
                        !Array.isArray(P_est) || P_est.length !== 2 || !Array.isArray(P_est[0]) || P_est[0].length !== 2) {
                        console.error(`Invalid input shapes for updateStatePlot: x: ${x}, x_est: ${x_est}, P_est: ${P_est}`);
                        return;
                    }
                    //get the max width of the container for the state-diagram plot
                    const maxY = maxVelocity+100;
                    const lMargin = 40;
                    const rMargin = 40;
                    const layout = {
                        title: 'Kalman Filter State Space',
                        legend: {
                            orientation: 'h',
                            yanchor: 'top',
                            xanchor: 'center',
                            y: 1.05,
                            x: 0.5,
                        },
                        yaxis: {
                            title: 'Velocity (Pixels/Second)',
                            range: [-maxY,maxY],
                        },
                        xaxis: {
                            title: 'Position (Pixels)',
                            range: [0,container.clientWidth-lMargin-rMargin], // axis labels take some space
                        },
                        margin: {
                        l: lMargin,
                        r: rMargin,
                        t: 50,
                        b: 40,
                        },
                        hovermode: 'closest',
                    }
                    function getPlotPosition(x) {
                        return positiveModulo(x[0][0], container.clientWidth + 2*robot.clientWidth) - robot.clientWidth/2; //robot.clientWidth/2 is an offset so dot is at front or robot
                    }
                    // Apply the new position and wheel rotation to the robot
                    const pixel_position = getPlotPosition(x);
    
                    const center_true = {
                        x: [pixel_position],
                        y: [x[1][0]],
                        type: 'scatter',
                        mode: 'markers',
                        marker: { color: 'black' },
                        showlegend: true,
                        name: 'True State'
                    }
                    const x_est_mod = [[getPlotPosition(x_est)],
                                        [x_est[1][0]]];
                    if (x_est_mod[1][0] > maxY+ 50) {
                        // just draw an arrow indicating where it is
                        const center_est_arrow = {
                            x: [x_est_mod[0][0]],
                            y: [maxY-30],
                            type: 'scatter',
                            mode: 'markers',
                            marker: {
                                symbol: 'triangle-up',
                                size: 12,
                                color: 'red'
                            },
                            showlegend: true,
                            name: 'Estimated State',
                        }
                        const traces = [center_true, center_est_arrow];
                        Plotly.react('full-kalman-filter-state-diagram', traces, layout);
                    }
                    else if (x_est_mod[1][0] < -maxY-50) {
                        const center_est_arrow = {
                            x: [x_est_mod[0][0]],
                            y: [-maxY+30],
                            type: 'scatter',
                            mode: 'markers',
                            marker: {
                                symbol: 'triangle-down',
                                size: 12,
                                color: 'red'
                            },
                            showlegend: true,
                            name: 'Estimated State',
                        }
                        const traces = [center_true, center_est_arrow];
                        Plotly.react('full-kalman-filter-state-diagram', traces, layout);
                    }
                    else {
                        const center_est = {
                            x: [x_est_mod[0][0]],
                            y: [x_est_mod[1][0]],
                            type: 'scatter',
                            mode: 'markers',
                            marker: { color: 'red' },
                            showlegend: false,
                        }
                        const contours_est = generateGaussianEllipticalContours(x_est_mod, P_est, color='red', name='Estimated State');
                        const traces = [center_true, center_est].concat(contours_est);
                        Plotly.react('full-kalman-filter-state-diagram', traces, layout);
                    }
                }
                
                ///// Animation Start/Stop Controls /////
                // Stop running the animation when the user can't see it
                let animationRunning = true;
                function startAnimation() {
                    animationRunning = true;
                    requestAnimationFrame(animateRobot);
                }
                function stopAnimation() {
                    animationRunning = false;
                }
                function resetAnimation() {
                    resetAllVariables();
                    renderAnimationAndPlot(x, x_est, P_est);
                }
                // Stop running when the user can't see the animation
                function handleIntersection(entries) {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            startAnimation();
                        } else {
                            stopAnimation();
                        }
                    });
                }
                const observer = new IntersectionObserver(handleIntersection, {
                    root: null, // Use the viewport as the root
                    threshold: 0.1 // Trigger when 10% of the element is visible
                });
                observer.observe(container);
    
                // Start/Stop/Reset buttons
                startButton.addEventListener('click', () => {
                    startAnimation();
                });
                stopButton.addEventListener('click', () => {
                    stopAnimation();
                });
                resetButton.addEventListener('click', () => {
                    resetAnimation();
                });
    
                // Function to animate the robot
                function renderAnimationAndPlot(x, x_est, P_est) {
                    const wheelRotation = positiveModulo(x[0][0]/wheelRadius * 180/Math.PI, 360);
        
                    // Apply the new position and wheel rotation to the robot
                    const pixel_position = positiveModulo(x[0][0], container.clientWidth + 2*robot.clientWidth) - robot.clientWidth;
                    robot.style.left = `${pixel_position}px`;
                    // In the SVG the front wheel was originally drawn centered at 134.39388px 156.62283px
                    // then the whole front wheel was translated by -47.066795px, 7.9443462px
                    // We need to rotate the wheel about its translated center
                    frontWheel.style.transformOrigin = `${134.39388 - 47.066795}px ${156.62283 + 7.9443462}px`;
                    frontWheel.style.transform = `rotate(${wheelRotation}deg) translate(-47.066795px, 7.9443462px)`;
        
                    // In the SVG the rear wheel was originally drawn centered at 134.39388px 156.62283px
                    // then the whole rear wheel was translated by -95px, 7.9443462px
                    // We need to rotate the wheel about its translated center
                    rearWheel.style.transformOrigin = `${134.39388 - 95}px ${156.62283 + 7.9443462}px`;
                    rearWheel.style.transform = `rotate(${wheelRotation}deg) translate(-95px, 7.9443462px)`;
    
                    updateStatePlot(x, x_est, P_est);
                }
    
                let t_prev;
                let KF_t_prev; // Kalman Filter runs at slower rate than true state
                let measurement_t_prev; // Measurement update runs at slower rate than Kalman Filter
    
                function animateRobot(timestamp) {
                    if (!animationRunning) {
                        t_prev = undefined;
                        return;
                    }
                    if (timestamp === undefined) {
                        console.error('animateRobot: timestamp is undefined. Ensure that animateRobot is being called by requestAnimationFrame or otherwise being passed a timestamp.');
                    }
                    if (t_prev === undefined) {
                        t_prev = timestamp;
                        KF_t_prev = timestamp;
                        measurement_t_prev = timestamp;
                    }
                    // True state
                    const dt = (timestamp - t_prev) / 1000;
                    t_prev = timestamp;
                    x = trueStateModel(x, dt, throttle, wheelRadius, maxVelocity, maxAngularAcceleration);
    
                    // Kalman state
                    const KF_dt = (timestamp - KF_t_prev) / 1000; // ms to seconds
                    const meas_dt = (timestamp - measurement_t_prev) / 1000;
                    if (KF_dt >= KF_dt_min) {
                        KF_t_prev = timestamp;
                        if (meas_dt >= meas_dt_min) {
                            measurement_t_prev = timestamp;
                            // Take a measurement if possible
                            const z = trueMeasurementModel(x);
                            [x_est, P_est] = propagateKalmanFilter(x_est, P_est, KF_dt, throttle, wheelRadius, maxAngularAcceleration, z);
                        } else {
                            [x_est, P_est] = propagateKalmanFilter(x_est, P_est, KF_dt, throttle, wheelRadius, maxAngularAcceleration);
                        }
                    }
    
                    renderAnimationAndPlot(x, x_est, P_est);
                    requestAnimationFrame(animateRobot);
                }
        
                // Start the animation
                updatePupilPosition(450,170);
                requestAnimationFrame(animateRobot);
    
                })();
            </script>
    </div>

    <p class="expandable-content-text" onclick="toggleExpandableContent('why-not-perfect')">
        Why is this not perfect?
    </p>
    <p class="expanded-content" id="why-not-perfect">
        Despite all the proofs of theoretical optimality, there are still some 
        fundamental limitations to the Kalman Filter. In this example, we see 
        that the Kalman Filter doesn't track the maximum velocity very well, because 
        the filter is only using the throttle value to predict the velocity, and
        has no way of recognizing that the real robot in fact has a maximum 
        velocity.  Also, running the filter at a slow rate causes the state estimate 
        to lag the true state by a significant amount most of the time.  
        These are errors that we encounter for a system that is actually linear with minimal noise!
        When you implement a Kalman Filter for systems in the wild, you'll likely
        have to manually account for these types of errors in order to get 
        good performance.
    </p>

    <h2>Summary</h2>
    <p>
        The <strong>Kalman Filter</strong> is an algorithmic blueprint for incorporating different sources 
        of information into a unified probailistic state estimate. It outlines two ways to 
        propagate the current state estimate to the next:
        <ol>
            <li>Predict: Incorporate information about the default dynamics of the system</li>
            <li>Update: Fuse sensor information with the most recent state estimate 
                using the Kalman Gain</li>
        </ol>
        The <strong>Kalman Gain</strong> is an operator that takes vectors in the 
        measurement space as input, and outputs the weighted contribution of that measurement 
        vector to the total state estimate. This operation can be interpreted as having two 
        steps (in either order):
        <ul>
            <li>Convert from the space of measurements to the space of states using \( \measurementMatrix^{-1} \)</li>
            <li>Weight the contribution of the measurement to the state estimate in proportion
                to the inverse of its variance (either \( \varianceRatio \) or \( \varianceRatioState \))</li>
        </ul>
        In practice the measurement matrix is not invertible, but by bundling these two steps together
        we can define the Kalman Gain without ever using \( \measurementMatrix^{-1} \).
    </p>
    <p>
        My aim with this article was to give you an intuitive understanding of how the Kalman Filter 
        works, but from here there is a lot of beatiful math that proves the Filter's optimality under certain 
        conditions, and also provides insight on how to handle situations that don't quite match this precise setup. 
        Hopefully while exploring this article you realized that there are many obvious 
        shortcomings. For example, 
        What if your model isn't linear? What if you don't know the covariance matrix for your sensors? How do small changes 
        in parameters like the timestep (or accumulation of numerical error) affect the filter's behavior? 
    </p>
    <p>
        As far as dealing with non-linearities, there are several different algorithms you should look into:
        the Particle Filter, the Unscented Kalman Filter (UKF), and the Extended Kalman Filter (EKF). All three of these 
        are similar in that they combine probabilistic state and measurement information, but they differ in 
        how they incorporate non-linear process models and how they represent the state estimate distribution. 
    </p>
    <p>
        In total I've thrown you 17 variables -- that can be a lot to keep track of! 
        I've collected them all here so you have a single reference, though clicking 
        on the variables throughout the article will give the same information.
        You can also choose the naming convention using the dropdown menu above, 
        which should make it easier to learn across multiple sources.
    </p>
    <table id="variable-description-table">
        <thead>
            <tr>
                <th>Symbol </th>
                <th>Name</th>
                <th>Description</th>
                <th>Dimension</th>
            </tr>
        </thead>
        <tbody id="variable-description-table-body">

        </tbody>
    </table>
    <style>
        #variable-description-table {
            border-collapse: collapse;
            border: 1px solid black;
        }
        #variable-description-table th, #variable-description-table td {
            border: 1px solid black;
            padding: 4px;
        }
        #variable-description-table td:first-child {
            text-align: center;
        }
    </style>

    <script>
        // For every FormulaElement in variables (from formula-element-definitions.js)
        // add a row to the table
        for (const variable of Object.values(variables)) {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td class="variable-symbol ${variable.div_name}">\\(${variable.symbol}\\)</td>
                <td class="variable-name ${variable.div_name}">${variable.display_name}</td>
                <td class="variable-description ${variable.div_name}">${variable.description}</td>
                <td class="variable-dimension ${variable.div_name}">${variable.dimension}</td>
            `;
            document.getElementById('variable-description-table-body').appendChild(row);
        }
    </script>

    <h2>References</h2>
    <p>
        Gilja V, et.al. A high-performance neural prosthesis enabled by control algorithm design. 
        Nat Neurosci. 2012 Dec;15(12):1752-7. doi: 10.1038/nn.3265. Epub 2012 Nov 18. PMID: 23160043; PMCID: PMC3638087.
        https://pmc.ncbi.nlm.nih.gov/articles/PMC3638087/#S8 
    </p>
</body>
<script>
    activateButtonsAndContent(['option1-button'], ['update-step-option1'], ['option2-button'], ['update-step-option2']);
    document.addEventListener('DOMContentLoaded', function() {
        const gaussianMultiplicationRule = document.getElementById('gaussian-multiplication-rule');
        const duplicateGaussianMultiplicationRule = document.getElementById('duplicate-gaussian-multiplication-rule');
        duplicateGaussianMultiplicationRule.innerHTML = gaussianMultiplicationRule.innerHTML;
        const duplicateGaussianMultiplicationRule2 = document.getElementById('duplicate-gaussian-multiplication-rule-2');
        duplicateGaussianMultiplicationRule2.innerHTML = gaussianMultiplicationRule.innerHTML;
        const duplicateGaussianMultiplicationRule4 = document.getElementById('duplicate-gaussian-multiplication-rule-4');
        duplicateGaussianMultiplicationRule4.innerHTML = gaussianMultiplicationRule.innerHTML;
        const duplicateGaussianMultiplicationRule3 = document.getElementById('duplicate-gaussian-multiplication-rule-3');
        duplicateGaussianMultiplicationRule3.innerHTML = gaussianMultiplicationRule.innerHTML;
        const duplicateWhatWeWantOfGaussians = document.getElementById('duplicate-what-we-want-of-gaussians');
        duplicateWhatWeWantOfGaussians.innerHTML = document.getElementById('what-we-want-of-gaussians').innerHTML;

        // Coudn't copy the entire interactive question, but could copy the content
        const bayesRuleExplanation2 = document.getElementById('bayes-rule-explanation-2');
        bayesRuleExplanation2.innerHTML = document.getElementById('bayes-rule-explanation').innerHTML;
        const matrixFractionsExplanation2 = document.getElementById('matrix-fractions-explanation-2');
        matrixFractionsExplanation2.innerHTML = document.getElementById('matrix-fractions-explanation').innerHTML;
        const covarianceMatrixSimplification2 = document.getElementById('covariance-matrix-simplification-2');
        covarianceMatrixSimplification2.innerHTML = document.getElementById('covariance-matrix-simplification').innerHTML;
    });

</script>
</html>